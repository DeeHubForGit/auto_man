<!-- Admin Calendar Section -->
<script src="assets/js/googleCalendar.js?v=3"></script>
<style>
  /* Scoped styles for calendar bookings */
  #section-calendar .booking-card {
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: visible;
  }
  
  #section-calendar .booking-card .booking-time {
    font-weight: 600;
  }
  
  /* Compact view - hide details by default */
  #section-calendar .booking-card .booking-details {
    display: none;
  }
  
  /* Expanded view on hover - show full details - DESKTOP ONLY */
  @media (min-width: 769px) {
    #section-calendar .booking-card:hover {
      z-index: 50 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: scale(1.02);
      height: auto !important;
      min-height: fit-content !important;
      overflow: visible;
    }
    
    #section-calendar .booking-card:hover .booking-details {
      display: block;
    }
    /* Desktop hover: hide entire summary when details are shown to avoid duplicates */
    #section-calendar .booking-card:hover .booking-summary {
      display: none !important;
    }
  }
  
  /* Compact summary styling */
  #section-calendar .booking-summary {
    line-height: 1.2;
  }
  
  #section-calendar .booking-summary .booking-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* Cancel button styling */
  #section-calendar .booking-cancel-btn {
      width: 18px;
      height: 18px;
      padding: 0;                       /* tightest fit */
      border-radius: 50%;               /* perfect circle */
      background: transparent;
      color: #dc2626;                   /* normal soft red */
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease, color 0.15s ease;
      margin-left: auto;
      margin-right: -4px;
      flex-shrink: 0;                   /* prevent shrinking */
  }

  #section-calendar .booking-cancel-btn:hover {
      background: rgba(220, 38, 38, 0.10); /* tighter, softer halo */
      color: #b91c1c;                      /* subtle darkening */
  }

  #section-calendar .booking-cancel-btn svg {
    display: block;
  }
  
  @media (max-width: 768px) {
    /* Hide red cancel X on collapsed cards in the grid */
    #section-calendar .booking-card:not(.booking-active) .booking-cancel-btn {
      display: none !important;
    }

    /* Show it again on the expanded mobile popup */
    #section-calendar .booking-card.booking-active .booking-cancel-btn {
      display: inline-flex !important;
    }
  }


  /* Wrapper for button and content to use flexbox */
  #section-calendar .booking-card-content {
    display: flex;
    align-items: flex-start;
    gap: 2px;
  }
  
  #section-calendar .booking-card-text {
    flex: 1;
    min-width: 0;
  }
  
  #section-calendar .booking-cancel-btn {
    align-self: flex-start;
    margin-top: 0px;
  }
  
  /* Show cancel button always for now */
  #section-calendar .booking-card .booking-cancel-btn {
    display: inline-flex;
  }
  
  /* Ensure status dropdown is always visible in expanded state */
  #section-calendar .booking-card .booking-status-select {
    margin-top: 0.25rem;
  }
  
  /* Red $ marker for payment required bookings */
  #section-calendar .payment-marker {
    color: #ff4d4d;
    font-weight: 700;
    margin-left: 4px;
    font-size: 0.9em;
  }
  
  /* Payment toggle checkbox and label */
  #section-calendar .payment-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    margin: 4px 0;
  }
  
  #section-calendar .payment-toggle-checkbox {
    transform: scale(1.0);
    cursor: pointer;
  }
  
  /* Make disabled but checked radio buttons still visible */
  #section-calendar input[type="radio"]:disabled:checked {
    opacity: 1;
  }
  
  #section-calendar .payment-label {
    font-weight: 600;
  }
  
  /* Red warning when payment not yet received */
  #section-calendar .payment-toggle.unpaid .payment-label {
    color: #ff4d4d;
  }
  
  /* Ensure header row and time column are visible on dark background */
  #section-calendar .calendar-header {
    color: #111827 !important;
    background-color: #f3f4f6 !important;
  }
  #section-calendar .calendar-time-cell {
    color: #111827 !important;
    background-color: #f9fafb !important;
    padding: 4px 6px; /* Tighter vertical spacing for mobile */
    position: sticky;
    left: 0;
    z-index: 10;
  }
  
  /* Hide mobile-only elements on desktop */
  #section-calendar .mobile-only {
    display: none;
  }
  
  /* Tighter row height for mobile */
  #section-calendar #weekGrid > div > div {
    min-height: 56px; /* down from 80px */
  }
  
  /* Fix for header time cell */
  #section-calendar .calendar-header:first-child {
    position: sticky;
    left: 0;
    z-index: 20;
    background-color: #f3f4f6 !important;
  }
  
  /* Calendar grid cells */
  #section-calendar #weekGrid > div {
    background-color: white !important;
    border-color: #e5e7eb !important;
  }
  
  /* Calendar title and text */
  #section-calendar h2,
  #section-calendar .text-sm {
    color: #111827 !important;
  }
  
  /* Calendar navigation buttons – reuse global btn/btn-primary colours */
  #section-calendar .calendar-nav-btn {
    /* size tweaks only */
    height: 32px;
    min-width: 32px;
    padding: 0.25rem 0.5rem;
    line-height: 1;
    border-radius: 0.5rem; /* match other buttons */
    font-weight: 500;
  }

  /* Make icon-based button match text buttons */
  #section-calendar .calendar-nav-btn svg {
    width: 20px;
    height: 20px;
    display: block;
  }
  
  /* Mobile scroll improvements */
  #section-calendar #calendar {
    overflow-x: auto;
    overflow-y: auto;
  }
  
  /* Desktop: wider columns */
  #section-calendar #weekGrid {
    min-width: auto; /* Allow mobile to shrink */
  }
  
  /* Personal appointment modal */
  .admin-modal-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(15, 23, 42, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
  }

  .admin-modal-backdrop.hidden {
    display: none;
  }

  /* Appointment modal layout */
  .admin-modal {
    background-color: #0b1727;           /* same dark panel as admin */
    border: 1px solid #1E40AF;          /* subtle blue border */
    border-radius: 0.75rem;
    padding: 0.75rem 1.5rem 1.5rem;     /* ↓ smaller top padding */
    max-width: 480px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    box-shadow: 0 20px 25px rgba(15, 23, 42, 0.5);
  }

  .admin-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;              /* ↓ less space below header */
  }

  .admin-modal-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin: 0;                          /* remove extra h2 margin */
    color: #e5e7eb;
  }

  /* Make sure calendar-wide h2 colour does not override the title */
  #section-calendar .admin-modal-title {
    color: #e5e7eb !important;
  }

  .admin-modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #9ca3af;
    cursor: pointer;
  }

  .admin-modal-close:hover {
    color: #ffffff;
  }

  .admin-modal-body .form-group {
    margin-bottom: 0.5rem;
  }

  .admin-modal-body label {
    display: block;
    font-size: 0.875rem;
    margin-bottom: 0.15rem;
    color: #e5e7eb;
  }

  /* Override section-calendar inline color for all modal labels */
  #section-calendar .admin-modal-body label {
    color: #e5e7eb !important;
  }

  /* Ensure radio button and checkbox labels are visible - override section-calendar inline style */
  #section-calendar .admin-modal-body label span {
    color: #e5e7eb !important;
  }

  #section-calendar .admin-modal-body .inline-options label {
    display: flex !important;
    color: #e5e7eb !important;
  }

  #section-calendar .admin-modal-body .inline-options label span {
    color: #e5e7eb !important;
  }

  /* Ensure help text is visible */
  #section-calendar .admin-modal-body p {
    color: #9ca3af !important;
  }

  #section-calendar .admin-modal-body .text-gray-400 {
    color: #9ca3af !important;
  }

  /* Error messages must stay red */
  #section-calendar .admin-modal-body p.text-red-500 {
    color: #ef4444 !important;
  }

  .admin-modal-body .form-input {
    width: 100%;
    box-sizing: border-box;
    height: 32px;
    padding: 6px 10px;
    border-radius: 0.375rem;
    border: 1px solid #1f2937;
    background-color: #020617;
    color: #e5e7eb;
    font-size: 14px;
    line-height: 1.2;
  }

  /* Mobile: slightly tighter so it fits comfortably */
  @media (max-width: 480px) {
    .admin-modal-body .form-input {
      height: 30px;
      padding: 5px 9px;
      font-size: 13px;
    }
  }

  .admin-modal-body .form-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 1px #3b82f6;
  }

  /* Time row: keep both columns equal width and aligned */
  .admin-modal-body .form-row {
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  .admin-modal-body .form-row .form-group {
    flex: 1;
    min-width: 0;
  }

  /* Prevent End time (optional) wrapping which causes vertical misalignment */
  .admin-modal-body .form-row .form-group label {
    white-space: nowrap;
  }

  .admin-modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 1rem;
  }
  
  /* Visible scrollbar for mobile */
  #section-calendar #calendar::-webkit-scrollbar {
    height: 8px;
    width: 8px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 4px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
  }
  
  /* Firefox scrollbar */
  #section-calendar #calendar {
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 #f1f5f9;
  }
  
  /* Mini spinner for new booking status */
  #section-calendar .mini-spinner {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid rgba(107, 114, 128, 0.35);
    border-top-color: rgba(107, 114, 128, 1);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    vertical-align: -2px;
    margin-right: 8px;
  }

  #section-calendar #appt-end[readonly] {
    opacity: 0.75;
    cursor: not-allowed;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* Mobile: narrower columns so all 7 days fit */
  @media (max-width: 768px) {
  /* Always hide elements marked web-only on mobile (even when expanded) */
  #section-calendar .web-only { display: none !important; }
    /* Hide desktop-only content in compact blue blocks */
    #section-calendar .booking-card .desktop-only {
      display: none !important;
    }
    
    /* Show mobile-only content */
    #section-calendar .booking-card .mobile-only {
      display: block !important;
    }
    
    /* In expanded view, show everything */
    #section-calendar .booking-card.booking-active .desktop-only {
      display: block !important;
    }
    
    #section-calendar #weekGrid {
      grid-template-columns: 35px repeat(7, 1fr) !important;
      min-width: 100% !important; /* Remove forced scroll, fit to screen */
    }

    #section-calendar .calendar-header,
    #section-calendar .calendar-time-cell {
      padding: 2px 1px;
      font-size: 9px;
      line-height: 1.0;
      text-align: center;
    }

    /* Slightly shorter rows to reduce vertical scroll */
    #section-calendar #weekGrid > div > div {
      min-height: 48px;
    }
    
    /* Reduce cell padding for tighter fit */
    #section-calendar #weekGrid > div > div {
      padding: 1px;
    }
    
    /* Mobile: compact blocks, expand on tap */
    /* Default: show as a simple bar with name/suburb */
    #section-calendar .booking-card {
      /* Colors set via inline styles for booking vs non-booking */
      border-left: none !important;
      border-radius: 2px;
      padding: 2px 3px !important;
      overflow: hidden;
      font-size: 9px !important;
      line-height: 1.2;
      font-weight: 500;
    }
    
    /* Hide cancel button in compact mobile view to prevent accidental presses */
    #section-calendar .booking-card .booking-cancel-btn {
      display: none !important;
    }
    
    /* Show cancel button in expanded mobile popup */
    #section-calendar .booking-card.booking-active .booking-cancel-btn {
      display: inline-flex !important;
    }
    
    /* Show minimal info in compact view */
    #section-calendar .booking-card .booking-summary {
      display: block !important;
    }
    
    /* Hide detailed info by default */
    #section-calendar .booking-card .booking-details {
      display: none;
    }

    /* Expanded: centered modal wider for readability */
    #section-calendar .booking-card.booking-active {
      /* Background color set via inline styles (blue-200 for bookings, gray-100 for non-bookings) */
      border-left: 2px solid #3b82f6 !important;
      padding: 12px 16px !important;
      z-index: 50 !important;
      overflow: visible;
      position: fixed !important;
      left: 50% !important;
      top: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 90vw !important;
      max-width: 420px !important;
      height: auto !important;
      max-height: 80vh !important;
      overflow-y: auto !important;
      box-shadow: 0 14px 48px rgba(0,0,0,0.35) !important;
      font-size: 13px !important;
      border-radius: 12px !important;
    }
    
    /* Text color set via inline styles (dark blue for bookings, dark gray for non-bookings) */
    #section-calendar .booking-card.booking-active .booking-name { 
      font-weight: 600;
    }
    /* Hide mobile summary when expanded to avoid duplication (details remain visible) */
    #section-calendar .booking-card.booking-active .booking-summary { display: none !important; }
    
    /* Move cancel button left on mobile expanded view to avoid overlap with close X */
    #section-calendar .booking-card.booking-active .booking-cancel-btn { 
      margin-right: 24px !important; 
    }
    
    /* Close button for mobile modal (neutral gray, overlays content) */
    #section-calendar .booking-close-btn {
      position: absolute;
      top: 10px;           /* align with cancel button */
      right: 10px;
      width: 18px;
      height: 18px;
      background: transparent;  /* no fill */
      color: #6b7280 !important; /* gray-500 */
      border: none;
      border-radius: 50%;       /* still clickable circle area */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: bold;
      line-height: 0.75;
      z-index: 60;
    }
    
    #section-calendar .booking-close-btn:hover {
      background: rgba(0,0,0,0.04);
      color: #374151 !important; /* gray-700 */
    }

    #section-calendar .booking-card.booking-active .booking-details {
      display: block;
    }
    
    /* Backdrop for closing modal */
    #section-calendar .booking-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 45;
    }
    
    #section-calendar .booking-backdrop.active {
      display: block;
    }

    /* Ensure appointment type labels are visible in dark modal */
    .appointment-type-options span {
      color: #ffffff !important;
    }
  }
  
  /* Fix iOS/real-mobile layout for Start/End time in New appointment modal */
  .appt-time-row {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }

  @media (min-width: 640px) {
    .appt-time-row {
      grid-template-columns: 1fr 1fr;
    }
  }

  /* Make sure the modal is always reachable on mobile */
  @media (max-width: 768px) {
    .admin-modal-backdrop {
      align-items: flex-start;
      padding: 16px;
    }
  }

  /* Compact, consistent control sizing (modal only) */
  #section-calendar .admin-modal-body .form-input {
    height: 34px !important;
    min-height: 34px !important;
    padding: 3px 5px !important;
    font-size: 14px !important;
    line-height: 1.2 !important;
  }

  /* Date + time row: always on one line with fixed widths */
  #section-calendar .appt-datetime-row {
    display: grid;
    grid-template-columns: 114px 110px 110px;
    gap: 8px;
    align-items: start;
  }

  /* Mobile: slightly tighter to fit */
  @media (max-width: 480px) {
    #section-calendar .admin-modal-body .form-input {
      height: 32px !important;
      min-height: 32px !important;
      padding: 3px 5px !important;
      font-size: 13px !important;
    }

    #section-calendar .appt-datetime-row {
      grid-template-columns: 114px 104px 104px;
      gap: 6px;
    }
  }

  /* Mobile: reduce horizontal padding on time inputs for better fit */
  @media (max-width: 768px) {
    #section-calendar #appt-start,
    #section-calendar #appt-end {
      padding-left: 5px !important;
      padding-right: 5px !important;
    }
  }
  
  /* Reduce padding around ALL controls in the admin modal */
  #section-calendar .admin-modal-body .form-input,
  #section-calendar .admin-modal-body select,
  #section-calendar .admin-modal-body textarea {
    padding: 4px 6px !important;
  }

  /* iPhone Safari: Date row then Times row, KEEP FIXED WIDTHS (no expand) */
  @supports (-webkit-touch-callout: none) {
    @media (max-width: 768px) {

      /* Layout: Date on its own row, Start+End on next row */
      #section-calendar .appt-datetime-row {
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        grid-template-areas:
          "date  date"
          "start end" !important;
        gap: 10px !important;
        align-items: start !important;
        justify-content: start !important;
      }

      #section-calendar .appt-datetime-row .form-group:nth-child(1) { grid-area: date; justify-self: start; }
      #section-calendar .appt-datetime-row .form-group:nth-child(2) { grid-area: start; }
      #section-calendar .appt-datetime-row .form-group:nth-child(3) { grid-area: end; }

      /* Fixed widths (pick the numbers you want) */
      #section-calendar #appt-date { width: 120px !important; max-width: 120px !important; }
      #section-calendar #appt-start,
      #section-calendar #appt-end  { width: 120px !important; max-width: 120px !important; }

      /* Stop iOS grid children doing weird overflow overlap */
      #section-calendar .appt-datetime-row .form-group { min-width: 0 !important; }
      #section-calendar #appt-start,
      #section-calendar #appt-end,
      #section-calendar #appt-date { box-sizing: border-box !important; display: block !important; }
    }
  }

  /* iPhone Safari: vertically centre text inside date/time inputs */
  @supports (-webkit-touch-callout: none) {
    @media (max-width: 768px) {
      #section-calendar #appt-date,
      #section-calendar #appt-start,
      #section-calendar #appt-end {
        height: 32px !important;
        line-height: 32px !important;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
      }
    }
  }

</style>
<section id="section-calendar" class="section-content bg-white border rounded-2xl shadow-sm p-5" style="background-color: white !important; color: #111827 !important;">
  <!-- Week range + navigation -->
  <div class="flex flex-wrap items-center justify-between gap-2 mb-3" role="group" aria-label="Calendar navigation">
    <div class="flex flex-wrap items-center gap-3 min-w-0">
      <span id="weekRange" class="text-base sm:text-lg font-bold text-blue-600 w-full sm:w-auto">
        Week: 09/11/25 - 15/11/25
      </span>
      <div class="flex flex-wrap items-center gap-2 min-w-0">
        <button id="prevWeek" class="btn btn-primary-light calendar-nav-btn !px-2 !py-1" aria-label="Previous week">←</button>
        <button id="nextWeek" class="btn btn-primary calendar-nav-btn !px-2 !py-1" aria-label="Next week">→</button>
        <button id="todayBtn" class="btn btn-outline-blue calendar-nav-btn !px-2 !py-1" title="Today" aria-label="Jump to today">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8"  y1="2" x2="8"  y2="6"></line>
            <line x1="3"  y1="10" x2="21" y2="10"></line>
            <text x="12" y="16" text-anchor="middle" font-size="9" font-weight="bold" fill="currentColor">{{DAY}}</text>
          </svg>
        </button>
        <button id="refreshBtn" class="btn btn-outline-blue calendar-nav-btn !px-2 !py-1" title="Refresh calendar" aria-label="Refresh calendar">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="23 4 23 10 17 10"></polyline>
            <polyline points="1 20 1 14 7 14"></polyline>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg>
        </button>
        <button id="btn-new-appointment" class="btn btn-primary btn-sm ml-2" title="New appointment">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
            <line x1="12" y1="14" x2="12" y2="18"></line>
            <line x1="10" y1="16" x2="14" y2="16"></line>
          </svg>
          <span class="hidden sm:inline ml-1">New appointment</span>
        </button>
        <span id="newBookingStatus" class="ml-0 sm:ml-3 text-sm text-gray-500 hidden w-full sm:w-auto break-words" aria-live="polite"></span>
      </div>
    </div>
  </div>
  
  <!-- No bookings message - displayed below navigation -->
  <div id="noBookingsMsg" class="text-blue-500 font-semibold text-center mb-3 hidden">
    No bookings found for this week
  </div>

  <div id="calendar" class="overflow-auto max-h-[600px] relative">
    <div id="weekGrid" class="grid grid-cols-8 text-sm" style="grid-template-columns: 80px repeat(7, minmax(120px, 1fr));"></div>
  </div>

  <!-- Add Appointment Modal -->
  <div id="appointment-modal-backdrop" class="admin-modal-backdrop hidden">
    <div class="admin-modal">
      <div class="admin-modal-header">
        <h2 class="admin-modal-title">New appointment</h2>
        <button type="button" id="appointment-modal-close" class="admin-modal-close">&times;</button>
      </div>


      <form id="appointment-form" class="admin-modal-body" novalidate>
        <!-- Appointment Type -->
        <div class="form-group">
          <label>Type<span class="text-red-500">*</span></label>
          <div class="inline-options flex gap-4 appointment-type-options">
            <label class="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="appointmentType" value="booking" checked class="cursor-pointer">
              <span class="text-sm text-white">Lesson booking</span>
            </label>
            <label class="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="appointmentType" value="personal" class="cursor-pointer">
              <span class="text-sm text-white">Personal appointment</span>
            </label>
          </div>
        </div>

        <!-- Service (Lesson bookings only) -->
        <div id="booking-service-field" class="form-group" style="display:block;">
          <label for="bookingService">Service<span class="text-red-500">*</span></label>
          <select id="bookingService" class="form-input">
            <option value="">Select a service...</option>
            <!-- Options populated dynamically from SITE_CONFIG.BOOKING_CATEGORIES -->
          </select>
          <p id="bookingService-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Title (Personal appointments only) -->
        <div id="personal-title-field" class="form-group" style="display:none;">
          <label for="appt-title">Title<span class="text-red-500">*</span></label>
          <input id="appt-title" name="title" type="text" class="form-input" />
          <p id="appt-title-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Date + time row (desktop) -->
        <div class="appt-datetime-row">
          <!-- Date -->
          <div class="form-group">
            <label for="appt-date">Date<span class="text-red-500">*</span></label>
            <input id="appt-date" name="date" type="date" class="form-input" />
            <p id="appt-date-error" class="text-xs text-red-500 mt-1 hidden"></p>
          </div>

          <!-- Start -->
          <div class="form-group">
            <label for="appt-start">Start<span class="text-red-500">*</span></label>
            <input id="appt-start" name="startTime" type="time" class="form-input" />
            <p id="appt-start-error" class="text-xs text-red-500 mt-1 hidden"></p>
          </div>

          <!-- End -->
          <div class="form-group">
            <label for="appt-end" id="appt-end-label">End</label>
            <input id="appt-end" name="endTime" type="time" class="form-input" />
          </div>
        </div>

        <!-- Location (Personal appointments only) -->
        <div id="personal-location-field" class="form-group" style="display:none;">
          <label for="appt-location">Location<span class="text-gray-400"> (optional)</span></label>
          <input id="appt-location" name="location" type="text" class="form-input" />
          <p id="appt-location-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Booking-specific fields -->
        <div id="bookingFields" class="mt-3" style="display:block;">
          <!-- Client mode -->
          <div class="form-group">
            <label>Client<span class="text-red-500">*</span></label>
            <div class="inline-options flex gap-4">
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="clientMode" value="existing" checked class="cursor-pointer">
                <span class="text-sm text-gray-200">Existing</span>
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="clientMode" value="new" class="cursor-pointer">
                <span class="text-sm text-gray-200">New</span>
              </label>
            </div>
          </div>

          <!-- Existing client -->
          <div id="existingClientFields">
            <div class="form-group">
              <label for="existingClientSelect">Select client<span class="text-red-500">*</span></label>
              <select id="existingClientSelect" class="form-input">
                <option value="">Loading clients...</option>
              </select>
              <p id="existingClientSelect-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
          </div>

          <!-- New client -->
          <div id="newClientFields" style="display:none;">
            <div class="form-group">
              <label for="newClientFirstName">First name<span class="text-red-500">*</span></label>
              <input id="newClientFirstName" type="text" class="form-input">
              <p id="newClientFirstName-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientLastName">Last name<span class="text-red-500">*</span></label>
              <input id="newClientLastName" type="text" class="form-input">
              <p id="newClientLastName-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientEmail">Email address<span class="text-red-500">*</span></label>
              <input id="newClientEmail" type="email" class="form-input">
              <p id="newClientEmail-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientMobile">Mobile<span class="text-red-500">*</span></label>
              <input id="newClientMobile" type="text" class="form-input" placeholder="e.g. 0412 345 678">
              <p id="newClientMobile-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
          </div>

          <!-- Pickup -->
          <div class="form-group">
            <label for="bookingPickupLocation">Pickup address<span class="text-red-500">*</span></label>
            <input id="bookingPickupLocation" type="text" class="form-input" placeholder="e.g. 123 Main St, Melbourne VIC 3000">
            <p id="bookingPickupLocation-error" class="text-xs text-red-500 mt-1 hidden"></p>
            
            <!-- Suggestion button (hidden by default) -->
            <button type="button" id="bookingPickupLocation-suggestion" class="hidden mt-2 w-full rounded-md border border-blue-300 bg-blue-50 px-3 py-2 text-left text-sm text-blue-900 hover:bg-blue-100 cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-400">
              <div class="font-semibold mb-0.5 text-xs text-blue-800">Suggested address (tap to use)</div>
              <div class="truncate text-blue-700" id="bookingPickupLocation-suggestion-text"></div>
            </button>
          </div>

          <!-- Payment required -->
          <div class="form-group">
            <div class="flex items-center gap-2 flex-wrap">
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="checkbox" id="bookingPaid" class="cursor-pointer">
                <span class="text-sm">Paid?</span>
              </label>

              <input id="bookingAmountPaid" type="number" min="0" step="0.01" inputmode="decimal" class="form-input" style="width: 120px;" placeholder="0.00">
            </div>
            <p class="text-xs text-gray-400 mt-1">Check when payment has been received (cash, transfer, etc)</p>
          </div>

          <!-- Status -->
          <div class="form-group">
            <label for="bookingStatus">Status</label>
            <select id="bookingStatus" class="form-input">
              <option value="confirmed">Confirmed</option>
              <option value="completed">Completed</option>
              <option value="cancelled">Cancelled</option>
              <option value="no_show">No Show</option>
            </select>
          </div>
        </div>

        <div class="admin-modal-footer">
          <button type="button" id="appointment-cancel" class="btn btn-secondary btn-sm">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary btn-sm" id="appointment-save">
            Save
          </button>
        </div>
      </form>
    </div>
  </div>
</section>

<script>
(function() {
  // Calendar logic
  function addDays(d, n) { const r = new Date(d); r.setDate(r.getDate() + n); return r; }
  let weekStart = new Date();

  // Edit state for personal appointments
  let editingPersonalAppt = false;
  let editingPersonalGoogleEventId = null;

  // Edit state for bookings
  let editingBooking = false;
  let editingBookingId = null;
  let editingBookingData = null;

  // Service duration configuration (in minutes) – populated from config
  const SERVICE_DURATIONS = {};
  const SERVICE_PRICE_CENTS = {};

  // Helper: Round time to next 15 minutes
  function roundToNext15Minutes(date = new Date()) {
    const d = new Date(date);
    const minutes = d.getMinutes();
    const remainder = minutes % 15;
    const offset = remainder === 0 ? 0 : 15 - remainder;
    d.setMinutes(minutes + offset, 0, 0);
    return d;
  }

  // Helper: Format time as HH:MM for time input
  function formatTimeForInput(date) {
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  // Helper: Format date as YYYY-MM-DD for date input (local time, not UTC)
  function formatDateForInputLocal(dateObj) {
    if (!dateObj) return '';
    const yyyy = dateObj.getFullYear();
    const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
    const dd = String(dateObj.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  }

  // Helper: Add minutes to a time string (HH:MM format)
  function addMinutesToTime(timeString, date, minutesToAdd) {
    if (!timeString || !date) return '';
    const [hours, mins] = timeString.split(':').map(Number);
    const d = new Date(date);
    d.setHours(hours, mins, 0, 0);
    d.setMinutes(d.getMinutes() + minutesToAdd);
    return formatTimeForInput(d);
  }

  // Reset edit state for personal appointments
  function resetPersonalEditState() {
    editingPersonalAppt = false;
    editingPersonalGoogleEventId = null;
  }

  // Reset edit state for bookings
  function resetBookingEditState() {
    editingBooking = false;
    editingBookingId = null;
    editingBookingData = null;
    editingBookingGoogleEventId = null;

    // Re-enable client mode switching for non-edit flows
    const newClientRadio = document.querySelector('input[name="clientMode"][value="new"]');
    if (newClientRadio) newClientRadio.disabled = false;
    const existingClientRadio = document.querySelector('input[name="clientMode"][value="existing"]');
    if (existingClientRadio) existingClientRadio.disabled = false;
  }

  // Helper to enable/disable appointment type radio buttons
  function setAppointmentTypeRadiosDisabled(disabled) {
    document.querySelectorAll('input[name="appointmentType"]').forEach(r => {
      r.disabled = !!disabled;
    });
  }

  // Helper to control save button loading state
  let apptSaveOriginalHtml = null;

  function setAppointmentSaveLoading(isLoading, labelText) {
    const btn = document.getElementById('appointment-save');
    if (!btn) return;

    if (isLoading) {
      if (apptSaveOriginalHtml == null) apptSaveOriginalHtml = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = `<span class="mini-spinner"></span>${labelText || 'Processing...'}`;
    } else {
      btn.disabled = false;
      if (apptSaveOriginalHtml != null) {
        btn.innerHTML = apptSaveOriginalHtml;
        apptSaveOriginalHtml = null;
      }
    }
  }

  // Modal handling for personal appointments
  const btnNewAppointment = document.getElementById("btn-new-appointment");
  const apptBackdrop = document.getElementById("appointment-modal-backdrop");
  const apptForm = document.getElementById("appointment-form");
  const apptCloseBtn = document.getElementById("appointment-modal-close");
  const apptCancelBtn = document.getElementById("appointment-cancel");
  let formHasChanges = false;
  let bookingAmountManuallyEdited = false;

  function openAppointmentModal(defaults = {}) {
    // Reset form to defaults
    apptForm.reset();
    bookingAmountManuallyEdited = false;
    
    // Reset modal title and button text to defaults
    const modalTitle = document.querySelector("#appointment-modal-backdrop h2");
    if (modalTitle) {
      modalTitle.textContent = "New Appointment";
    }
    const submitBtn = document.getElementById("appointment-save");
    if (submitBtn) {
      submitBtn.textContent = "Create Appointment";
    }
    
    // Reset appointment type to "booking" (default)
    const bookingRadio = document.querySelector('input[name="appointmentType"][value="booking"]');
    const personalRadio = document.querySelector('input[name="appointmentType"][value="personal"]');
    if (bookingRadio) bookingRadio.checked = true;
    if (personalRadio) personalRadio.checked = false;
    
    // Reset client mode to "existing" (default)
    const existingClientRadio = document.querySelector('input[name="clientMode"][value="existing"]');
    if (existingClientRadio) existingClientRadio.checked = true;

    // Enable client mode radios for new appointments
    document.querySelectorAll('input[name="clientMode"]').forEach(r => {
      r.disabled = false;
    });
    
    // Show/hide fields based on default type (booking)
    document.getElementById('personal-title-field').style.display = 'none';
    document.getElementById('personal-location-field').style.display = 'none';
    document.getElementById('booking-service-field').style.display = 'block';
    document.getElementById('bookingFields').style.display = 'block';
    document.getElementById('existingClientFields').style.display = 'block';
    document.getElementById('newClientFields').style.display = 'none';
    
    // Enable appointment type radios for new appointments
    setAppointmentTypeRadiosDisabled(false);
    
    // Set end time field to readonly for bookings
    const endTimeInput = document.getElementById('appt-end');
    endTimeInput.readOnly = true;
    document.getElementById('appt-end-label').innerHTML = 'End time';
    
    // Default date to today if not provided
    const today = new Date();
    const dateStr = defaults.date || formatDateForInputLocal(today);
    
    // Default start time to next 15 minutes if not provided and date is today
    let startTime = defaults.startTime || '';
    if (!startTime && dateStr === formatDateForInputLocal(today)) {
      const rounded = roundToNext15Minutes();
      startTime = formatTimeForInput(rounded);
    }
    
    // Populate defaults
    document.getElementById("appt-title").value = defaults.title || "";
    document.getElementById("appt-date").value = dateStr;
    document.getElementById("appt-start").value = startTime;
    document.getElementById("appt-end").value = defaults.endTime || "";
    document.getElementById("appt-location").value = defaults.location || "";

    // Clear all validation errors
    clearApptError("appt-title");
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("appt-location");
    clearApptError("bookingPickupLocation");
    
    // Hide pickup suggestion on fresh modal open
    hidePickupSuggestion();

    // Calculate initial end time for booking if service is selected
    updateBookingEndTime();

    formHasChanges = false; // Reset change tracking
    apptBackdrop.classList.remove("hidden");
  }

  function closeAppointmentModal(force = false) {
    // Check if there are unsaved changes
    if (!force && formHasChanges) {
      if (window.Modal && window.Modal.confirm) {
        window.Modal.confirm(
          "Do you want to save your changes?",
          () => {
            // User clicked Yes - trigger form submission
            apptForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
          },
          () => {
            // User clicked No - close without saving
            apptBackdrop.classList.add("hidden");
            apptForm.reset();
            clearApptError("bookingPickupLocation");
            hidePickupSuggestion();
            formHasChanges = false;
          },
          "Unsaved Changes",
          { confirmText: 'Yes', cancelText: 'No' }
        );
      } else {
        // Fallback to native confirm if Modal.js not available
        const confirmClose = confirm("You have unsaved changes. Are you sure you want to close?");
        if (!confirmClose) {
          return;
        }
        apptBackdrop.classList.add("hidden");
        apptForm.reset();
        clearApptError("bookingPickupLocation");
        hidePickupSuggestion();
        formHasChanges = false;
      }
      return;
    }
    
    apptBackdrop.classList.add("hidden");
    apptForm.reset();
    clearApptError("bookingPickupLocation");
    hidePickupSuggestion();
    formHasChanges = false;
    resetPersonalEditState();
    resetBookingEditState();
    setAppointmentTypeRadiosDisabled(false);
  }

  // Open modal in edit mode for a personal appointment
  function openEditPersonalAppointmentModal({ googleEventId, title, dateStr, startHHMM, endHHMM, location }) {
    // Set edit state
    editingPersonalAppt = true;
    editingPersonalGoogleEventId = googleEventId;
    
    // Fill form fields
    document.getElementById("appt-title").value = title || '';
    document.getElementById("appt-date").value = dateStr || '';
    document.getElementById("appt-start").value = startHHMM || '';
    document.getElementById("appt-end").value = endHHMM || '';
    document.getElementById("appt-location").value = location || '';
    
    // Force personal appointment mode (keep personal enabled so it shows as selected)
    const radioBooking = document.querySelector('input[name="appointmentType"][value="booking"]');
    const radioPersonal = document.querySelector('input[name="appointmentType"][value="personal"]');
    
    if (radioBooking) {
      radioBooking.checked = false;
      radioBooking.disabled = true; // Disable only booking to prevent switching
    }
    if (radioPersonal) {
      radioPersonal.checked = true;
      radioPersonal.disabled = false; // Keep personal enabled so selection is visible
      radioPersonal.dispatchEvent(new Event('change'));
    }
    
    // Update modal title to indicate editing
    const modalTitle = document.querySelector("#appointment-modal-backdrop h2");
    if (modalTitle) {
      modalTitle.textContent = "Edit Personal Appointment";
    }
    
    // Update submit button text
    const submitBtn = document.getElementById("appointment-save");
    if (submitBtn) {
      submitBtn.textContent = "Update Appointment";
    }
    
    // Open modal
    formHasChanges = false;
    apptBackdrop.classList.remove("hidden");
  }

  // Open modal in edit mode for a booking
  async function openEditBookingModal(booking) {
    // Set edit state
    editingBooking = true;
    editingBookingId = booking.id;
    editingBookingData = booking;
    editingBookingGoogleEventId = booking.google_event_id || booking.googleEventId || null;

    // Ensure dropdowns are populated before selecting values
    loadServices();
    await loadClients();
    
    // Extract date and time from ISO timestamp strings
    let dateStr = '';
    let startHHMM = '';
    let endHHMM = '';
    
    if (booking.start_time) {
      const startDate = new Date(booking.start_time);
      dateStr = formatDateForInputLocal(startDate);
      startHHMM = formatTimeForInput(startDate);
    }
    
    if (booking.end_time) {
      const endDate = new Date(booking.end_time);
      endHHMM = formatTimeForInput(endDate);
    }
    
    // Fill date/time fields
    document.getElementById("appt-date").value = dateStr || '';
    document.getElementById("appt-start").value = startHHMM || '';
    document.getElementById("appt-end").value = endHHMM || '';
    
    // Fill service
    const serviceSelect = document.getElementById("bookingService");
    if (serviceSelect && booking.service_code) {
      serviceSelect.value = booking.service_code;
    }
    
    // Fill pickup location
    document.getElementById("bookingPickupLocation").value = booking.pickup_location || '';
    
    // Fill Paid? (checkbox means paid). DB is is_paid.
    const paidCheckbox = document.getElementById("bookingPaid");
    if (paidCheckbox) paidCheckbox.checked = !!booking.is_paid;

    // Fill amount paid (stored in booking.price_cents)
    const amountInput = document.getElementById('bookingAmountPaid');
    if (amountInput) {
      amountInput.value = (typeof booking.price_cents === 'number')
        ? (booking.price_cents / 100).toFixed(2)
        : '';
    }

    // Fill status
    const statusSelect = document.getElementById('bookingStatus');
    if (statusSelect) {
      statusSelect.value = booking.status || 'confirmed';
    }

    // Client mode: keep Existing/New behavior (do not force or disable client mode radios)
    const existingRadio = document.querySelector('input[name="clientMode"][value="existing"]');
    const newRadio = document.querySelector('input[name="clientMode"][value="new"]');
    if (existingRadio) existingRadio.disabled = false;
    if (newRadio) newRadio.disabled = false;

    const existingClientSelect = document.getElementById("existingClientSelect");

    // Prefill existing client selection if possible
    let matchedExistingClient = false;
    if (existingClientSelect && booking.client_id) {
      existingClientSelect.value = booking.client_id;
      matchedExistingClient = !!existingClientSelect.value;
    }

    // Fallback to email match for older rows/inconsistencies
    if (!matchedExistingClient && existingClientSelect && booking.email) {
      const opts = Array.from(existingClientSelect.options);
      const match = opts.find(o => (o.dataset.email || '').toLowerCase() === booking.email.toLowerCase());
      if (match) {
        existingClientSelect.value = match.value;
        matchedExistingClient = true;
      }
    }

    // Prefill new client fields from booking (useful if user switches modes)
    const newFirstName = document.getElementById("newClientFirstName");
    const newLastName = document.getElementById("newClientLastName");
    const newEmail = document.getElementById("newClientEmail");
    const newMobile = document.getElementById("newClientMobile");
    if (newFirstName) newFirstName.value = booking.first_name || '';
    if (newLastName) newLastName.value = booking.last_name || '';
    if (newEmail) newEmail.value = booking.email || '';
    if (newMobile) newMobile.value = booking.mobile || '';

    // Choose a default client mode based on what we can prefill
    if (matchedExistingClient) {
      if (existingRadio) {
        existingRadio.checked = true;
        existingRadio.dispatchEvent(new Event('change'));
      }
    } else {
      if (newRadio) {
        newRadio.checked = true;
        newRadio.dispatchEvent(new Event('change'));
      }
    }
    
    // Force booking mode (disable type switching)
    const radioBooking = document.querySelector('input[name="appointmentType"][value="booking"]');
    const radioPersonal = document.querySelector('input[name="appointmentType"][value="personal"]');
    
    if (radioBooking) {
      radioBooking.checked = true;
      radioBooking.disabled = false; // Keep enabled so selection is visible
      radioBooking.dispatchEvent(new Event('change'));
    }
    if (radioPersonal) {
      radioPersonal.checked = false;
      radioPersonal.disabled = true; // Disable personal to prevent switching
    }
    
    // Update modal title
    const modalTitle = document.querySelector("#appointment-modal-backdrop h2");
    if (modalTitle) {
      modalTitle.textContent = "Edit Booking";
    }
    
    // Update submit button text
    const submitBtn = document.getElementById("appointment-save");
    if (submitBtn) {
      submitBtn.textContent = "Update Booking";
    }
    
    // Open modal
    formHasChanges = false;
    apptBackdrop.classList.remove("hidden");
  }

  // Validation helper functions
  function showApptError(fieldId, message) {
    const field = document.getElementById(fieldId);
    const error = document.getElementById(fieldId + "-error");
    
    if (!field || !error) return;
    
    field.classList.add('border-red-400');
    error.textContent = message;
    error.classList.remove('hidden');
  }

  function clearApptError(fieldId) {
    const field = document.getElementById(fieldId);
    const error = document.getElementById(fieldId + "-error");
    
    if (!field || !error) return;
    
    field.classList.remove('border-red-400');
    error.textContent = '';
    error.classList.add('hidden');
  }

  // Show pickup address suggestion
  function showPickupSuggestion(suggestion) {
    const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
    const suggestionText = document.getElementById('bookingPickupLocation-suggestion-text');
    
    if (!suggestionBtn || !suggestionText || !suggestion) return;
    
    suggestionText.textContent = suggestion;
    suggestionBtn.classList.remove('hidden');
  }

  // Hide pickup address suggestion
  function hidePickupSuggestion() {
    const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
    if (suggestionBtn) {
      suggestionBtn.classList.add('hidden');
    }
  }

  // New booking status helpers
  function showNewBookingStatus(message) {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    el.innerHTML = `<span class="mini-spinner"></span>${message}`;
    el.classList.remove('hidden');
  }

  function setNewBookingStatusText(message) {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    // Keep spinner if already present
    const hasSpinner = el.querySelector('.mini-spinner');
    el.innerHTML = `${hasSpinner ? '<span class="mini-spinner"></span>' : ''}${message}`;
    el.classList.remove('hidden');
  }

  function hideNewBookingStatus() {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    el.classList.add('hidden');
    el.innerHTML = '';
  }

  // Apply pickup address suggestion
  function applyPickupSuggestion() {
    const suggestionText = document.getElementById('bookingPickupLocation-suggestion-text');
    const pickupInput = document.getElementById('bookingPickupLocation');
    
    if (!suggestionText || !pickupInput) return;
    
    const suggestion = suggestionText.textContent;
    if (suggestion) {
      pickupInput.value = suggestion;
      clearApptError('bookingPickupLocation');
      hidePickupSuggestion();
      formHasChanges = true;
    }
  }

  // Set up suggestion button click handler
  const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
  if (suggestionBtn) {
    suggestionBtn.addEventListener('click', applyPickupSuggestion);
  }

  // Track changes to form inputs and clear errors on input
  apptForm.addEventListener("input", (e) => {
    formHasChanges = true;
    
    // Clear browser validation state
    if (e.target.setCustomValidity) {
      e.target.setCustomValidity('');
    }
    
    // Clear error for the field being edited
    if (e.target.id) {
      clearApptError(e.target.id);
      // Hide suggestion when user starts typing in pickup field
      if (e.target.id === 'bookingPickupLocation') {
        hidePickupSuggestion();
      }
    }
  });

  // Update end time based on service selection and start time
  function updateBookingEndTime() {
    const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;
    if (appointmentType !== 'booking') return;
    
    const serviceCode = document.getElementById('bookingService').value;
    const startTime = document.getElementById('appt-start').value;
    const date = document.getElementById('appt-date').value;
    
    if (!serviceCode || !startTime || !date) return;
    
    const duration = SERVICE_DURATIONS[serviceCode];
    if (!duration) {
      throw new Error(`No duration found for service: ${serviceCode}`);
    }
    
    const endTime = addMinutesToTime(startTime, date, duration);
    document.getElementById('appt-end').value = endTime;
  }

  // Toggle between personal appointment and booking
  const appointmentTypeRadios = document.querySelectorAll('input[name="appointmentType"]');
  appointmentTypeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const isBooking = radio.value === 'booking';
      const personalFields = document.getElementById('personal-title-field');
      const personalLocation = document.getElementById('personal-location-field');
      const bookingServiceField = document.getElementById('booking-service-field');
      const bookingFields = document.getElementById('bookingFields');
      const endTimeInput = document.getElementById('appt-end');
      const endTimeLabel = document.getElementById('appt-end-label');
      
      if (isBooking) {
        personalFields.style.display = 'none';
        personalLocation.style.display = 'none';
        bookingServiceField.style.display = 'block';
        bookingFields.style.display = 'block';
        endTimeInput.readOnly = true;
        endTimeLabel.innerHTML = 'End time';
        updateBookingEndTime();
      } else {
        personalFields.style.display = 'block';
        personalLocation.style.display = 'block';
        bookingServiceField.style.display = 'none';
        bookingFields.style.display = 'none';
        endTimeInput.readOnly = false;
        endTimeLabel.innerHTML = 'End time<span class="text-gray-400"></span>';
      }
    });
  });

  // Toggle between existing client and new client
  const clientModeRadios = document.querySelectorAll('input[name="clientMode"]');
  clientModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const isNew = radio.value === 'new';
      const existingFields = document.getElementById('existingClientFields');
      const newFields = document.getElementById('newClientFields');
      
      if (isNew) {
        existingFields.style.display = 'none';
        newFields.style.display = 'block';
      } else {
        existingFields.style.display = 'block';
        newFields.style.display = 'none';
      }
    });
  });

  // Listen for service selection change to update end time
  document.getElementById('bookingService')?.addEventListener('change', () => {
    updateBookingEndTime();

    // New booking only: default amount from service price (do not overwrite manual edits)
    if (editingBooking) return;
    if (bookingAmountManuallyEdited) return;

    const serviceCode = document.getElementById('bookingService')?.value || '';
    const cents = SERVICE_PRICE_CENTS[serviceCode];

    const amountInput = document.getElementById('bookingAmountPaid');
    if (!amountInput) return;

    if (typeof cents === 'number') {
      amountInput.value = (cents / 100).toFixed(2);
    }
  });

  // Listen for start time change to update end time
  document.getElementById('appt-start')?.addEventListener('change', () => {
    updateBookingEndTime();
  });

  // Listen for date change to update end time
  document.getElementById('appt-date')?.addEventListener('change', () => {
    updateBookingEndTime();
  });

  // Add real-time validation for pickup address
  const pickupInput = document.getElementById('bookingPickupLocation');
  if (pickupInput) {
    pickupInput.addEventListener('blur', function() {
      const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;
      if (appointmentType !== 'booking') return; // Only validate for bookings
      
      const value = this.value.trim();
      if (!value) return; // Don't show error on empty until submit
      
      const validation = validatePickupAddressForBooking(value);
      if (!validation.valid) {
        showApptError('bookingPickupLocation', validation.message);
      } else {
        clearApptError('bookingPickupLocation');
      }
    });
  }

  const bookingAmountInput = document.getElementById('bookingAmountPaid');
  if (bookingAmountInput) {
    bookingAmountInput.addEventListener('input', () => {
      bookingAmountManuallyEdited = true;
    });
  }

  // Load clients from database
  async function loadClients() {
    const selectEl = document.getElementById('existingClientSelect');
    if (!selectEl) return;

    try {
      const { data: clients, error } = await window.supabaseClient
        .from('client')
        .select('id, first_name, last_name, email, mobile')
        .order('first_name');

      if (error) {
        console.error('[admin-calendar] Error loading clients:', error);
        selectEl.innerHTML = '<option value="">Error loading clients</option>';
        return;
      }

      if (!clients || clients.length === 0) {
        selectEl.innerHTML = '<option value="">No clients found</option>';
        return;
      }

      // Populate select with clients
      selectEl.innerHTML = '<option value="">Select a client...</option>' +
        clients.map(c => {
          const fullName = [c.first_name, c.last_name].filter(Boolean).join(' ');
          return `<option value="${c.id}" data-first-name="${c.first_name || ''}" data-last-name="${c.last_name || ''}" data-email="${c.email || ''}" data-mobile="${c.mobile || ''}">${fullName} (${c.email || 'no email'})</option>`;
        }).join('');

      console.log(`[admin-calendar] Loaded ${clients.length} clients`);
    } catch (err) {
      console.error('[admin-calendar] Exception loading clients:', err);
      selectEl.innerHTML = '<option value="">Error loading clients</option>';
    }
  }

  // Helper function to get bookable services from config
  function getBookingServicesFromConfig() {
    if (!window.SITE_CONFIG || !Array.isArray(window.SITE_CONFIG.BOOKING_CATEGORIES)) {
      console.warn('[admin-calendar] SITE_CONFIG.BOOKING_CATEGORIES not available');
      return [];
    }

    return window.SITE_CONFIG.BOOKING_CATEGORIES
      .filter(cat => !cat.comingSoon)          // skip manual "coming soon"
      .flatMap(cat => (cat.services || []).map(svc => {
        // Require durationMinutes as a number - no parsing, no fallbacks
        if (typeof svc.durationMinutes !== 'number') {
          throw new Error(`Missing durationMinutes for service: ${svc.id}`);
        }

        // Populate SERVICE_DURATIONS map with service id as key
        SERVICE_DURATIONS[svc.id] = svc.durationMinutes;

        // Populate SERVICE_PRICE_CENTS map with service id as key
        // Supports prices like 110, "110", "$110", "110.00", "$110.00"
        let priceRaw = svc.price;

        if (typeof priceRaw === 'string') {
          priceRaw = priceRaw.trim().replace(/[$,\s]/g, '');
        }

        const priceNum = Number(priceRaw);

        if (Number.isFinite(priceNum) && priceNum >= 0) {
          SERVICE_PRICE_CENTS[svc.id] = Math.round(priceNum * 100);
        } else {
          // If price is missing or invalid, do NOT set a value (leave undefined)
        }

        return {
          id: svc.id,              // used as <option> value
          name: svc.name,
          duration: svc.duration,  // e.g. "1 hour"
          durationMinutes: svc.durationMinutes,
          price: svc.price,
          categoryId: cat.id,
          categoryName: cat.name
        };
      }));
  }

  // Populate service dropdown from config
  function loadServices() {
    const serviceSelect = document.getElementById('bookingService');
    if (!serviceSelect) return;

    // Clear existing options except the first (placeholder)
    serviceSelect.innerHTML = '<option value="">Select a service...</option>';

    const services = getBookingServicesFromConfig();
    
    if (services.length === 0) {
      console.warn('[admin-calendar] No services found in BOOKING_CATEGORIES');
      return;
    }

    services.forEach(svc => {
      const opt = document.createElement('option');
      opt.value = svc.id;                       // must match SERVICE_DURATIONS key
      // Label e.g. "Automatic Driving Lesson 1 hour" or "Senior Automatic Driving Lesson 1 hour"
      opt.textContent = `${svc.name} ${svc.duration}`;
      serviceSelect.appendChild(opt);
    });

    console.log(`[admin-calendar] Loaded ${services.length} services from config`);
    console.log('[admin-calendar] Service durations:', SERVICE_DURATIONS);
  }

  // Load clients and services when modal opens
  const originalOpenModal = openAppointmentModal;
  openAppointmentModal = function(defaults = {}) {
    originalOpenModal(defaults);
    loadClients();
    loadServices();
  };

  btnNewAppointment.addEventListener("click", () => {
    openAppointmentModal();
  });

  apptCloseBtn.addEventListener("click", () => closeAppointmentModal());
  apptCancelBtn.addEventListener("click", () => closeAppointmentModal());

  // Close when clicking outside the modal
  apptBackdrop.addEventListener("click", (e) => {
    if (e.target === apptBackdrop) {
      closeAppointmentModal();
    }
  });

  // Helper function to validate address format (delegates to validation.js)
  function isValidAddress(addr) {
    return window.Validation?.isProbablyValidAuAddress?.(addr) ?? false;
  }

  // Enhanced pickup validation with helpful error messages (uses validation.js)
  function validatePickupAddressForBooking(addr) {
    const trimmed = (addr || '').trim();
    if (!trimmed) {
      return { valid: false, message: 'Pickup address is required' };
    }

    const isValid = window.Validation?.isProbablyValidAuAddress?.(trimmed) ?? false;
    if (!isValid) {
      return { valid: false, message: 'Please provide a valid pickup address.' };
    }

    return { valid: true, message: null };
  }

  // Validate address with Google Maps via Edge Function (delegates to validation.js)
  async function validateAddressWithBackend(address) {
    const result = await window.Validation.validateAuAddressAsync(address, window.supabaseClient);

    const isValid = !!result?.valid;
    const suggestion = result?.formatted || null;
    const issueCode = result?.meta?.issue || result?.reason || 'unknown';

    // If Google can resolve it but returns a different formatted address,
    // show a suggestion but do NOT block saving.
    if (isValid && suggestion) {
      const typed = (address || '').trim().replace(/\s+/g, ' ').toLowerCase();
      const formatted = (suggestion || '').trim().replace(/\s+/g, ' ').toLowerCase();

      if (typed !== formatted) {
        return {
          valid: true,
          message: null,
          issue: 'suggestion_available',
          suggestion,
          meta: result?.meta || null
        };
      }
    }

    // Convert validation.js format to our format
    return {
      valid: isValid,
      message: isValid
        ? null
        : (window.Validation.getPickupLocationIssueMessage(issueCode) || 'Please provide a valid pickup address.'),
      issue: issueCode,
      suggestion,
      meta: result?.meta || null
    };
  }

  function formatAuDateTime(dateInput) {
    if (!dateInput) return '';

    const d = new Date(dateInput);

    return d.toLocaleString('en-AU', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
  }

  // WARNING ONLY: Check local DB for overlapping bookings, then continue.
  // - Does not block saving.
  // - Local booking table only (no Google).
  async function warnIfBookingClash(startIso, endIso, excludeBookingId) {
    try {
      if (!window.supabaseClient) return;

      if (!startIso || !endIso) return;

      let q = window.supabaseClient
        .from('booking')
        .select('id, start_time, end_time, first_name, last_name, event_title, is_booking, status')
        .eq('is_deleted', false)
        .neq('status', 'cancelled')
        .lt('start_time', endIso)
        .gt('end_time', startIso)
        .order('start_time', { ascending: true })
        .limit(5);

      if (excludeBookingId) {
        q = q.neq('id', excludeBookingId);
      }

      const { data, error } = await q;

      if (error) {
        console.warn('[clash-warning] Clash check query error (continuing anyway):', error);
        return;
      }

      if (!data || data.length === 0) return;

      const lines = data.map(b => {
        const label = b.is_booking
          ? ([b.first_name, b.last_name].filter(Boolean).join(' ') || 'Booking')
          : (b.event_title || 'Appointment');
        const start = formatAuDateTime(b.start_time);
        const end = formatAuDateTime(b.end_time);
        return `• ${label} (${start} - ${end})`;
      });

      const msg =
        `Warning: This overlaps ${data.length} existing appointment(s).\n\n` +
        lines.join('\n') +
        `\n\nClick OK to continue.`;

      if (window.Modal && window.Modal.requireOk) {
        await window.Modal.requireOk(msg, 'Overlap Warning', { confirmText: 'OK' });
      } else {
        alert(msg);
      }
    } catch (e) {
      console.warn('[clash-warning] Clash check failed (continuing anyway):', e);
      return;
    }
  }
  
  // Helper function to convert 24-hour time to 12-hour format with AM/PM
  function convert24To12Hour(time24) {
    const [hours, minutes] = time24.split(':').map(Number);
    const period = hours >= 12 ? 'PM' : 'AM';
    const hours12 = hours % 12 || 12;
    return `${String(hours12).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
  }

  // Update the DB row for a personal appointment immediately after a successful Google update
  async function updatePersonalAppointmentRowInDb(googleEventId, { title, startIso, endIso, location }) {
    if (!googleEventId) return;

    const updateData = {
      event_title: title || null,
      start_time: startIso,
      end_time: endIso,
      pickup_location: location || null,
      updated_at: new Date().toISOString(),
    };

    const { error } = await window.supabaseClient
      .from('booking')
      .update(updateData)
      .eq('google_event_id', googleEventId);

    if (error) {
      console.warn('[appointment] DB update failed (webhook will eventually correct it):', error);
    }
  }

  // Handle form submission
  apptForm.addEventListener("submit", async (event) => {
    event.preventDefault();

    // Hard guard: if we're editing a booking, always run booking update
    // (never route through the personal appointment submit handler)
    if (editingBooking && editingBookingId) {
      await handleBookingUpdate();
      return;
    }

    // Check appointment type
    const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;

    if (appointmentType === 'booking') {
      await handleBookingSubmit();
    } else {
      await handlePersonalAppointmentSubmit();
    }
  });

  // Handle personal appointment submission
  async function handlePersonalAppointmentSubmit() {
    const title = document.getElementById("appt-title").value.trim();
    const date = document.getElementById("appt-date").value;
    const startTime = document.getElementById("appt-start").value;
    const endTime = document.getElementById("appt-end").value;
    const location = document.getElementById("appt-location").value.trim();

    // Clear all errors first
    clearApptError("appt-title");
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("appt-location");

    // Validate required fields
    let hasError = false;
    if (!title) {
      showApptError("appt-title", "Title is required");
      hasError = true;
    }
    if (!date) {
      showApptError("appt-date", "Date is required");
      hasError = true;
    }
    if (!startTime) {
      showApptError("appt-start", "Start time is required");
      hasError = true;
    }
    // Location is optional free text, e.g. home, work, etc.  NO VALIDATION.

    if (hasError) {
      return;
    }

    try {
      // Convert 24-hour time to 12-hour format for the edge function
      const startTime12 = convert24To12Hour(startTime);
      const endTime12 = endTime ? convert24To12Hour(endTime) : null;

      // Build ISO timestamps for local overlap warning (TIMESTAMPTZ)
      const startIso = new Date(`${date}T${startTime}:00`).toISOString();
      const endIso = endTime
        ? new Date(`${date}T${endTime}:00`).toISOString()
        : new Date(`${date}T${startTime}:00`).toISOString();

      // Show loading state on save button
      setAppointmentSaveLoading(true, editingPersonalAppt ? 'Updating...' : 'Creating...');

      if (editingPersonalAppt && editingPersonalGoogleEventId) {
        // UPDATE mode
        console.log("[appointment] Updating personal appointment via edge function");

        let excludeId = null;
        if (editingPersonalAppt && editingPersonalGoogleEventId && window.supabaseClient) {
          try {
            const { data: existingRow, error: excludeErr } = await window.supabaseClient
              .from('booking')
              .select('id')
              .eq('google_event_id', editingPersonalGoogleEventId)
              .maybeSingle();
            if (excludeErr) {
              console.warn('[clash-warning] Exclude lookup error (continuing anyway):', excludeErr);
            }
            excludeId = existingRow?.id || null;
          } catch (e) {
            console.warn('[clash-warning] Exclude lookup failed (continuing anyway):', e);
          }
        }
        await warnIfBookingClash(startIso, endIso, excludeId);
        
        const { data, error } = await window.supabaseClient.functions.invoke('update-admin-appointment', {
          body: { 
            googleEventId: editingPersonalGoogleEventId,
            title,
            date,
            startTime: startTime12,
            endTime: endTime12,
            location
          }
        });

        if (error) {
          console.error("[appointment] Edge function error:", error);
          throw new Error(error.message || "Failed to update appointment");
        }

        if (!data || !data.ok) {
          console.error("[appointment] Edge function returned error:", data);
          throw new Error(data?.error || "Failed to update appointment");
        }

        console.log("[appointment] ✅ Appointment updated successfully:", data);

        // Immediate DB update so calendar refresh shows the change right away
        await updatePersonalAppointmentRowInDb(editingPersonalGoogleEventId, {
          title,
          startIso,
          endIso,
          location
        });

        closeAppointmentModal(true); // Force close without confirmation since we just saved

        // Show success message
        if (window.Modal && window.Modal.success) {
          window.Modal.success("Appointment updated successfully!", "Success");
        }

        // Refresh calendar to show updated appointment
        renderWeek(weekStart);
        
      } else {
        // CREATE mode
        console.log("[appointment] Creating personal appointment via edge function");

        await warnIfBookingClash(startIso, endIso, null);

        // Call edge function to create Google Calendar event and insert into DB
        const { data, error } = await window.supabaseClient.functions.invoke('create-admin-appointment', {
          body: { 
            title,
            date,
            startTime: startTime12,
            endTime: endTime12,
            location
          }
        });

        if (error) {
          console.error("[appointment] Edge function error:", error);
          throw new Error(error.message || "Failed to create appointment");
        }

        if (!data || !data.ok) {
          console.error("[appointment] Edge function returned error:", data);
          throw new Error(data?.error || "Failed to create appointment");
        }

        console.log("[appointment] ✅ Appointment created successfully:", data);
        const googleEventId = data?.googleEvent?.id;
        const bookingId = data?.bookingId;

        closeAppointmentModal(true); // Force close without confirmation since we just saved

        // Show success message
        if (window.Modal && window.Modal.success) {
          window.Modal.success("Appointment created successfully!", "Success");
        }

        // If bookingId is returned, the DB row already exists - just refresh immediately
        if (bookingId) {
          console.log("[appointment] ✓ Booking record created immediately, refreshing calendar...");
          renderWeek(weekStart);
          return; // Skip polling
        }

        // Fallback: Poll database for the new event (in case edge function didn't create the booking)
        console.log("[appointment] No bookingId returned, waiting for gcal-sync to process...", googleEventId);
        
        let pollAttempts = 0;
        const maxPolls = 10; // Try for up to 30 seconds (10 attempts x 3 seconds)
        
        const pollForEvent = async () => {
          pollAttempts++;
          setNewBookingStatusText(`waiting for new appointment...  (${pollAttempts}/${maxPolls})`);
          console.log(`[appointment] Checking database for new event (attempt ${pollAttempts}/${maxPolls})...`);
          
          try {
            // Query database directly for the Google event ID
            const { data: booking, error } = await window.supabaseClient
              .from('booking')
              .select('id, google_event_id')
              .eq('google_event_id', googleEventId)
              .maybeSingle();
            
            if (booking) {
              // Event found in database!
              console.log(`[appointment] ✅ Event found in database! Refreshing calendar once.`, booking);
              hideNewBookingStatus();
              renderWeek(weekStart);
              return; // Stop polling
            }
          
          if (error && error.code !== 'PGRST116') {
            // PGRST116 is "no rows returned" which is expected, other errors are real issues
            console.error('[appointment] Database query error:', error);
          }
          
          // Not found yet, continue polling if we haven't hit max attempts
          if (pollAttempts < maxPolls) {
            console.log(`[appointment] Event not yet in database, retrying in 3 seconds...`);
            setTimeout(pollForEvent, 3000);
          } else {
            console.warn(`[appointment] ⚠️ Event not found after ${maxPolls} attempts. Webhook may be delayed.`);
            hideNewBookingStatus();
            // Do one final refresh anyway
            renderWeek(weekStart);
          }
        } catch (err) {
          console.error('[appointment] Error polling for event:', err);
          if (pollAttempts < maxPolls) {
            setTimeout(pollForEvent, 3000);
          } else {
            hideNewBookingStatus();
          }
        }
      };
      
      // Start polling after 2 seconds (give webhook a head start)
      showNewBookingStatus('waiting for new appointment...');
      setTimeout(pollForEvent, 2000);
      }
    } catch (err) {
      console.error("[appointment] Failed to save appointment", err);
      
      // Show user-friendly error message
      if (window.Modal && window.Modal.error) {
        window.Modal.error(
          err.message || "Could not save appointment. Please try again.",
          "Error"
        );
      } else {
        alert("Could not save appointment. Please try again. Error: " + (err.message || err));
      }
    } finally {
      setAppointmentSaveLoading(false);
    }
  }

  // Handle booking update (edit mode)
  async function handleBookingUpdate() {
    const date = document.getElementById("appt-date").value;
    const startTime = document.getElementById("appt-start").value;
    const endTime = document.getElementById("appt-end").value;
    
    const serviceSelect = document.getElementById("bookingService");
    const serviceCode = serviceSelect.value;
    const serviceLabel = serviceSelect.options[serviceSelect.selectedIndex]?.text || "";

    const clientMode = document.querySelector('input[name="clientMode"]:checked')?.value || "existing";
    
    const existingClientSelect = document.getElementById("existingClientSelect");
    const clientId = clientMode === "existing" ? existingClientSelect.value : null;
    
    const firstName = clientMode === "new" 
      ? document.getElementById("newClientFirstName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.firstName || "";
    const lastName = clientMode === "new"
      ? document.getElementById("newClientLastName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.lastName || "";
    const email = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.email || ""
      : document.getElementById("newClientEmail").value.trim();
    const mobile = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.mobile || ""
      : document.getElementById("newClientMobile").value.trim();
    
    let pickupLocation = document.getElementById("bookingPickupLocation").value.trim();

    // Modal checkbox is Paid? (checked = paid). Persist as is_paid.
    const isPaid = document.getElementById("bookingPaid").checked;

    const status = document.getElementById('bookingStatus')?.value || 'confirmed';
    const amountPaidRaw = document.getElementById('bookingAmountPaid')?.value;
    const amountPaidCents = (amountPaidRaw === undefined || String(amountPaidRaw).trim() === '')
      ? undefined
      : Math.round(Number(amountPaidRaw) * 100);

    // Clear all errors first
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("bookingService");
    clearApptError("existingClientSelect");
    clearApptError("newClientFirstName");
    clearApptError("newClientLastName");
    clearApptError("newClientEmail");
    clearApptError("newClientMobile");
    clearApptError("bookingPickupLocation");

    // Validate required fields
    let hasError = false;
    
    if (!date) {
      showApptError("appt-date", "Date is required");
      hasError = true;
    }
    if (!startTime) {
      showApptError("appt-start", "Start time is required");
      hasError = true;
    }
    if (!serviceCode) {
      showApptError("bookingService", "Please select a service");
      hasError = true;
    }
    
    if (clientMode === "existing") {
      if (!clientId) {
        showApptError("existingClientSelect", "Please select a client");
        hasError = true;
      }
    } else {
      if (!firstName) {
        showApptError("newClientFirstName", "First name is required");
        hasError = true;
      }
      if (!lastName) {
        showApptError("newClientLastName", "Last name is required");
        hasError = true;
      }
      if (!email) {
        showApptError("newClientEmail", "Email is required");
        hasError = true;
      } else if (!window.Validation?.isValidEmail?.(email)) {
        showApptError("newClientEmail", "Please enter a valid email address");
        hasError = true;
      }
      if (!mobile) {
        showApptError("newClientMobile", "Mobile is required");
        hasError = true;
      } else if (!window.Validation?.isValidAuMobile?.(mobile)) {
        showApptError("newClientMobile", "Enter a valid AU mobile (e.g. 04XX XXX XXX or +61 4XX XXX XXX)");
        hasError = true;
      }
    }
    
    // Enhanced pickup address validation
    const pickupValidation = validatePickupAddressForBooking(pickupLocation);
    if (!pickupValidation.valid) {
      showApptError("bookingPickupLocation", pickupValidation.message);
      hasError = true;
    }

    if (hasError) {
      return;
    }

    // Show loading state on button only
    const saveBtn = document.getElementById('appointment-save');
    const originalBtnText = saveBtn ? saveBtn.textContent : '';
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Updating...';
    }

    try {
      // Validate address with Google Maps before saving
      console.log("[booking-update] Validating pickup address with Google Maps...");
      const backendValidation = await validateAddressWithBackend(pickupLocation);

      if (backendValidation.valid) {
        clearApptError("bookingPickupLocation");
      }

      // Show suggestion whenever available (even if address is valid)
      if (backendValidation.suggestion) {
        showPickupSuggestion(backendValidation.suggestion);
      } else {
        hidePickupSuggestion();
      }

      const isGoogleUnavailable =
        window.Validation?.isGoogleValidationUnavailable?.(backendValidation.meta) === true;

      const pickupValidToStore = isGoogleUnavailable ? null : true;
      const pickupIssueToStore = null;
      const pickupSuggestionToStore = null;
      const checkedAtToStore = isGoogleUnavailable ? null : new Date().toISOString();

      if (!backendValidation.valid && !isGoogleUnavailable) {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = originalBtnText;
        }
        
        // Show validation error
        showApptError("bookingPickupLocation", backendValidation.message);
        
        console.log("[booking-update] Address validation failed:", backendValidation.issue);
        return; // STOP HERE - do not save
      }

      if (!backendValidation.valid && isGoogleUnavailable) {
        // Show warning, but DO NOT block saving
        showApptError(
          "bookingPickupLocation",
          backendValidation.message ||
            "Google address validation is currently unavailable. Please manually check the address before continuing."
        );
      }
      
      console.log("[booking-update] Address validated successfully");
      console.log("[booking-update] Updating booking via edge function");

      // Convert 24-hour time to 12-hour format for the edge function
      const startTime12 = convert24To12Hour(startTime);
      const endTime12 = endTime ? convert24To12Hour(endTime) : null;

      if (!editingBookingId) {
        throw new Error("Missing booking id for update");
      }

      const googleEventId = editingBookingGoogleEventId || editingBookingData?.google_event_id;
      if (!googleEventId) {
        throw new Error("Missing Google Event ID for booking update");
      }

      pickupLocation = document.getElementById('bookingPickupLocation')?.value?.trim() || null;

      const payload = {
        type: "booking",
        bookingId: editingBookingId,
        googleEventId,
        serviceCode,
        serviceLabel,
        date,
        startTime: startTime12,
        endTime: endTime12,
        clientId: clientId || null,
        firstName,
        lastName: lastName || null,
        email,
        mobile,
        pickupLocation,
        isPaid,
      };

      console.log("[booking-update] Payload:", payload);

      // Local overlap warning only (does not block saving)
      const startIso = new Date(`${date}T${startTime}:00`).toISOString();
      const endIso = endTime
        ? new Date(`${date}T${endTime}:00`).toISOString()
        : new Date(`${date}T${startTime}:00`).toISOString();
      await warnIfBookingClash(startIso, endIso, editingBookingId);

      // Call edge function to update Google Calendar event and DB
      const { data, error } = await window.supabaseClient.functions.invoke('update-admin-booking', {
        body: payload
      });

      if (error) {
        console.error('[booking-update] invoke error:', error);

        let details = '';

        if (error.context?.body) {
          if (typeof error.context.body === 'string') {
            details = error.context.body;
          } else {
            try {
              details = JSON.stringify(error.context.body);
            } catch (e) {
              details = '';
            }
          }
        }

        // If body is useless, fall back to message
        if (!details || details === '{}' || details === 'null' || details === '""') {
          details = error.message || 'Unknown error';
        }

        if (window.Modal && window.Modal.error) {
          window.Modal.error(details, 'Error');
        } else {
          alert(details);
        }
        return;
      }

      if (!data || !data.ok) {
        console.error("[booking-update] Edge function returned error:", data);
        const details = data?.error || JSON.stringify(data || { error: 'Failed to update booking' });
        if (window.Modal && window.Modal.error) {
          window.Modal.error(details, 'Error');
        } else {
          alert(details);
        }
        return;
      }

      console.log("[booking-update] ✅ Booking updated successfully:", data);

      pickupLocation = document.getElementById('bookingPickupLocation')?.value?.trim() || null;

      // Immediate DB update so calendar refresh shows the change right away
      await updateBookingRowInDb(editingBookingId, {
        serviceCode,
        startIso,
        endIso,
        pickupLocation,
        isPaid,
        status,
        priceCents: Number.isFinite(amountPaidCents) ? amountPaidCents : undefined,
        clientId,
        firstName,
        lastName,
        email,
        mobile,

        // NEW: clear stale invalid validation metadata on save
        pickupValid: pickupValidToStore,
        pickupIssue: pickupIssueToStore,
        pickupSuggestion: pickupSuggestionToStore,
        validationCheckedAt: checkedAtToStore,
      });

      closeAppointmentModal(true); // Force close without confirmation since we just saved

      // Show success message
      if (window.Modal && window.Modal.success) {
        window.Modal.success("Booking updated successfully!", "Success");
      }

      // Refresh calendar to show updated booking
      renderWeek(weekStart);

      // If the bookings list is present on the page, refresh it so price/status changes show immediately
      if (window.loadAdminBookings) {
        try {
          await window.loadAdminBookings();
        } catch (e) {
          console.warn('[booking-update] Failed to refresh bookings list:', e);
        }
      }

    } catch (err) {
      console.error("[booking-update] Error updating booking:", err);
      if (window.Modal && window.Modal.error) {
        window.Modal.error(
          err.message || "Could not update booking. Please try again.",
          "Error"
        );
      } else {
        alert("Failed to update booking. Please try again. Error: " + (err.message || err));
      }
    } finally {
      // Re-enable save button
      const saveBtn = document.getElementById('appointment-save');
      if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText || 'Update Booking';
      }
    }
  }

  // Update the DB row for a booking immediately after a successful Google update
  async function updateBookingRowInDb(bookingId, { serviceCode, startIso, endIso, pickupLocation, isPaid, clientId, firstName, lastName, email, mobile }) {
    if (!bookingId) return;

    const updateData = {
      service_code: serviceCode || null,
      start_time: startIso,
      end_time: endIso,
      pickup_location: pickupLocation || null,
      is_paid: !!isPaid,
      client_id: clientId || null,
      first_name: firstName || null,
      last_name: lastName || null,
      email: email || null,
      mobile: mobile || null,
      updated_at: new Date().toISOString(),
    };

    // Optional fields
    if (arguments.length > 1) {
      const opts = arguments[1] || {};
      if (typeof opts.status === 'string') {
        updateData.status = opts.status;
      }
      if (opts.priceCents !== undefined) {
        updateData.price_cents = opts.priceCents;
      }

      if (opts.pickupValid !== undefined) {
        updateData.is_pickup_location_valid = opts.pickupValid;
      }
      if (opts.pickupIssue !== undefined) {
        updateData.pickup_location_issue = opts.pickupIssue;
      }
      if (opts.pickupSuggestion !== undefined) {
        updateData.pickup_location_suggestion = opts.pickupSuggestion;
      }
      if (opts.validationCheckedAt !== undefined) {
        updateData.validation_checked_at = opts.validationCheckedAt;
      }
    }

    const { error } = await window.supabaseClient
      .from('booking')
      .update(updateData)
      .eq('id', bookingId);

    if (error) {
      console.warn('[booking-update] DB update failed (webhook will eventually correct it):', error);
    }
  }

  // Handle booking submission
  async function handleBookingSubmit() {
    // Check if we're in edit mode
    if (editingBooking && editingBookingId) {
      await handleBookingUpdate();
      return;
    }
    
    // Otherwise, proceed with create logic
    const date = document.getElementById("appt-date").value;
    const startTime = document.getElementById("appt-start").value;
    const endTime = document.getElementById("appt-end").value;
    
    const serviceSelect = document.getElementById("bookingService");
    const serviceCode = serviceSelect.value;
    const serviceLabel = serviceSelect.options[serviceSelect.selectedIndex]?.text || "";

    const clientMode = document.querySelector('input[name="clientMode"]:checked')?.value || "existing";
    
    const existingClientSelect = document.getElementById("existingClientSelect");
    const clientId = clientMode === "existing" ? existingClientSelect.value : null;
    
    const firstName = clientMode === "new" 
      ? document.getElementById("newClientFirstName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.firstName || "";
    const lastName = clientMode === "new"
      ? document.getElementById("newClientLastName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.lastName || "";
    const email = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.email || ""
      : document.getElementById("newClientEmail").value.trim();
    const mobile = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.mobile || ""
      : document.getElementById("newClientMobile").value.trim();
    
    let pickupLocation = document.getElementById("bookingPickupLocation").value.trim();

    // Modal checkbox is Paid? (checked = paid). Persist as is_paid.
    const isPaid = document.getElementById("bookingPaid").checked;

    const status = document.getElementById('bookingStatus')?.value || 'confirmed';
    const amountPaidRaw = document.getElementById('bookingAmountPaid')?.value;
    const amountPaidCents = (amountPaidRaw === undefined || String(amountPaidRaw).trim() === '')
      ? undefined
      : Math.round(Number(amountPaidRaw) * 100);

    // Clear all errors first
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("bookingService");
    clearApptError("existingClientSelect");
    clearApptError("newClientFirstName");
    clearApptError("newClientLastName");
    clearApptError("newClientEmail");
    clearApptError("newClientMobile");
    clearApptError("bookingPickupLocation");

    // Validate required fields
    let hasError = false;
    
    if (!date) {
      showApptError("appt-date", "Date is required");
      hasError = true;
    }
    if (!startTime) {
      showApptError("appt-start", "Start time is required");
      hasError = true;
    }
    if (!serviceCode) {
      showApptError("bookingService", "Please select a service");
      hasError = true;
    }
    
    if (clientMode === "existing") {
      if (!clientId) {
        showApptError("existingClientSelect", "Please select a client");
        hasError = true;
      }
    } else {
      if (!firstName) {
        showApptError("newClientFirstName", "First name is required");
        hasError = true;
      }
      if (!lastName) {
        showApptError("newClientLastName", "Last name is required");
        hasError = true;
      }
      if (!email) {
        showApptError("newClientEmail", "Email is required");
        hasError = true;
      } else if (!window.Validation?.isValidEmail?.(email)) {
        showApptError("newClientEmail", "Please enter a valid email address");
        hasError = true;
      }
      if (!mobile) {
        showApptError("newClientMobile", "Mobile is required");
        hasError = true;
      } else if (!window.Validation?.isValidAuMobile?.(mobile)) {
        showApptError("newClientMobile", "Enter a valid AU mobile (e.g. 04XX XXX XXX or +61 4XX XXX XXX)");
        hasError = true;
      }
    }
    
    // Enhanced pickup address validation
    const pickupValidation = validatePickupAddressForBooking(pickupLocation);
    if (!pickupValidation.valid) {
      showApptError("bookingPickupLocation", pickupValidation.message);
      hasError = true;
    }

    if (hasError) {
      return;
    }

    // Show loading state on button only
    const saveBtn = document.getElementById('appointment-save');
    const originalBtnText = saveBtn ? saveBtn.textContent : '';
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }

    try {
      // Validate address with Google Maps before saving
      console.log("[booking] Validating pickup address with Google Maps...");
      const backendValidation = await validateAddressWithBackend(pickupLocation);

      if (backendValidation.valid) {
        clearApptError("bookingPickupLocation");
      }

      // Show suggestion whenever available (even if address is valid)
      if (backendValidation.suggestion) {
        showPickupSuggestion(backendValidation.suggestion);
      } else {
        hidePickupSuggestion();
      }

      const isGoogleUnavailable =
        window.Validation?.isGoogleValidationUnavailable?.(backendValidation.meta) === true;

      const pickupValidToStore = isGoogleUnavailable ? null : true;
      const pickupIssueToStore = null;
      const pickupSuggestionToStore = null;
      const checkedAtToStore = isGoogleUnavailable ? null : new Date().toISOString();

      if (!backendValidation.valid && !isGoogleUnavailable) {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = originalBtnText;
        }
        
        // Show validation error
        showApptError("bookingPickupLocation", backendValidation.message);
        
        console.log("[booking] Address validation failed:", backendValidation.issue);
        return; // STOP HERE - do not save
      }

      if (!backendValidation.valid && isGoogleUnavailable) {
        // Show warning, but DO NOT block saving
        showApptError(
          "bookingPickupLocation",
          backendValidation.message ||
            "Google address validation is currently unavailable. Please manually check the address before continuing."
        );
      }
      
      console.log("[booking] Address validated successfully");
      console.log("[booking] Creating admin booking via edge function");

      // Convert 24-hour time to 12-hour format for the edge function
      const startTime12 = convert24To12Hour(startTime);
      const endTime12 = endTime ? convert24To12Hour(endTime) : null;

      pickupLocation = document.getElementById('bookingPickupLocation')?.value?.trim() || null;

      // Local overlap warning only (does not block saving)
      const startIso = new Date(`${date}T${startTime}:00`).toISOString();
      const endIso = endTime
        ? new Date(`${date}T${endTime}:00`).toISOString()
        : new Date(`${date}T${startTime}:00`).toISOString();
      await warnIfBookingClash(startIso, endIso, null);

      const payload = {
        appointmentType: "booking",
        serviceCode,
        serviceLabel,
        date,
        startTime: startTime12,
        endTime: endTime12,
        clientId: clientId || null,
        firstName,
        lastName: lastName || null,
        email,
        mobile,
        pickupLocation,
        isPaid,
      };

      console.log("[booking] Payload:", payload);

      // Call edge function to create Google Calendar event
      const { data, error } = await window.supabaseClient.functions.invoke('create-admin-booking', {
        body: payload
      });

      if (error) {
        console.error("[booking] Edge function error:", error);
        throw new Error(error.message || "Failed to create booking");
      }

      if (!data || !data.ok) {
        console.error("[booking] Edge function returned error:", data);
        throw new Error(data?.error || "Failed to create booking");
      }

      console.log("[booking] ✅ Booking created successfully:", data);
      const googleEventId = data?.googleEvent?.id;
      const bookingId = data?.bookingId;

      if (bookingId) {
        // Save status/amount immediately (optional fields)
        const extraUpdate = {};
        extraUpdate.is_pickup_location_valid = pickupValidToStore;
        extraUpdate.pickup_location_issue = pickupIssueToStore;
        extraUpdate.pickup_location_suggestion = pickupSuggestionToStore;
        extraUpdate.validation_checked_at = checkedAtToStore;
        if (typeof status === 'string') extraUpdate.status = status;
        if (Number.isFinite(amountPaidCents)) extraUpdate.price_cents = amountPaidCents;
        if (Object.keys(extraUpdate).length > 0) {
          const { error: extraErr } = await window.supabaseClient
            .from('booking')
            .update(extraUpdate)
            .eq('id', bookingId);
          if (extraErr) {
            console.warn('[booking] Optional status/amount update failed:', extraErr);
          }
        }

        console.log("[booking] ✓ Booking record created immediately, refreshing calendar...");
        closeAppointmentModal(true); // Force close without confirmation since we just saved

        // Show success message
        if (window.Modal && window.Modal.success) {
          window.Modal.success("Booking created successfully!", "Success");
        }

        renderWeek(weekStart);

        // If the bookings list is present on the page, refresh it so price/status changes show immediately
        if (window.loadAdminBookings) {
          try {
            await window.loadAdminBookings();
          } catch (e) {
            console.warn('[booking] Failed to refresh bookings list:', e);
          }
        }
        return; // Skip polling
      }

      closeAppointmentModal(true); // Force close without confirmation since we just saved

      // Show success message
      if (window.Modal && window.Modal.success) {
        window.Modal.success("Booking created successfully!", "Success");
      }

      // Poll database directly for the new event by Google event ID
      console.log("[booking] Waiting for gcal-sync to process the new event...", googleEventId);
      
      let pollAttempts = 0;
      const maxPolls = 10;
      
      const pollForEvent = async () => {
        pollAttempts++;
        setNewBookingStatusText(`waiting for new appointment...  (${pollAttempts}/${maxPolls})`);
        console.log(`[booking] Checking database for new event (attempt ${pollAttempts}/${maxPolls})...`);
        
        try {
          const { data: booking, error } = await window.supabaseClient
            .from('booking')
            .select('id, google_event_id')
            .eq('google_event_id', googleEventId)
            .maybeSingle();
          
          if (booking) {
            console.log(`[booking] ✅ Event found in database! Refreshing calendar.`, booking);
            hideNewBookingStatus();
            renderWeek(weekStart);

            // If the bookings list is present on the page, refresh it so price/status changes show immediately
            if (window.loadAdminBookings) {
              try {
                await window.loadAdminBookings();
              } catch (e) {
                console.warn('[booking] Failed to refresh bookings list:', e);
              }
            }
            return;
          }
          
          if (error && error.code !== 'PGRST116') {
            console.error('[booking] Database query error:', error);
          }
          
          if (pollAttempts < maxPolls) {
            console.log(`[booking] Event not yet in database, retrying in 3 seconds...`);
            setTimeout(pollForEvent, 3000);
          } else {
            console.warn(`[booking] ⚠️ Event not found after ${maxPolls} attempts.`);
            hideNewBookingStatus();
            renderWeek(weekStart);

            // If the bookings list is present on the page, refresh it so price/status changes show immediately
            if (window.loadAdminBookings) {
              try {
                await window.loadAdminBookings();
              } catch (e) {
                console.warn('[booking] Failed to refresh bookings list:', e);
              }
            }
          }
        } catch (err) {
          console.error('[booking] Error polling for event:', err);
          if (pollAttempts < maxPolls) {
            setTimeout(pollForEvent, 3000);
          } else {
            hideNewBookingStatus();
          }
        }
      };
      
      // Start polling after 2 seconds
      showNewBookingStatus('waiting for new appointment...');
      setTimeout(pollForEvent, 2000);
    } catch (err) {
      console.error("[booking] Error creating booking:", err);
      if (window.Modal && window.Modal.alert) {
        window.Modal.alert("Failed to create booking. Please try again.");
      } else {
        alert("Failed to create booking. Please try again.");
      }
    } finally {
      // Re-enable save button
      const saveBtn = document.getElementById('appointment-save');
      if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText || 'Save';
      }
    }
  }

  function renderWeek(startDate) {
    weekStart = new Date(startDate);
    weekStart.setDate(weekStart.getDate() - weekStart.getDay());
    // Set to start of day (midnight) to avoid timezone issues
    weekStart.setHours(0, 0, 0, 0);
    const grid = document.getElementById('weekGrid');
    if (!grid) return;
    grid.innerHTML = '';

    // Display week range
    const weekEnd = addDays(weekStart, 6);
    const rangeEl = document.getElementById('weekRange');
    if (rangeEl) {
      const formatShortDate = (date) => {
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = String(date.getFullYear()).slice(-2);
        return `${day}/${month}/${year}`;
      };
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      rangeEl.textContent = isMobile
        ? `${formatShortDate(weekStart)} - ${formatShortDate(weekEnd)}`
        : `Week: ${formatShortDate(weekStart)} - ${formatShortDate(weekEnd)}`;
    }

    // Header row with dates
    const headerRow = document.createElement('div');
    headerRow.className = 'contents';
    const days = ['Time', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    days.forEach((day, idx) => {
      const cell = document.createElement('div');
      cell.className = 'calendar-header font-semibold p-2 border sticky top-0 z-10';
      if (idx === 0) cell.classList.add('left-0', 'z-20');
      if (idx > 0) {
        const date = addDays(weekStart, idx - 1);
        // For mobile: show day name on line 1, date on line 2
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        if (isMobile) {
          cell.innerHTML = `<div style="line-height: 1.1;">${day}</div><div style="line-height: 1.1;">${date.getDate()}/${date.getMonth() + 1}</div>`;
        } else {
          cell.textContent = `${day} ${date.getDate()}/${date.getMonth() + 1}`;
        }
      } else {
        cell.textContent = day;
      }
      headerRow.appendChild(cell);
    });
    grid.appendChild(headerRow);

    // Time slots (8am-6pm)
    const dayCells = {};
    for (let h = 8; h < 18; h++) {
      const row = document.createElement('div');
      row.className = 'contents';
      const timeCell = document.createElement('div');
      timeCell.className = 'calendar-time-cell p-2 border sticky left-0 z-10 font-medium';
      timeCell.textContent = `${h}:00`;
      row.appendChild(timeCell);
      for (let d = 0; d < 7; d++) {
        const cell = document.createElement('div');
        cell.className = 'p-2 border min-h-[80px] relative overflow-visible cursor-pointer hover:bg-blue-50 transition-colors';
        cell.dataset.day = d;
        cell.dataset.hour = h;
        const key = `${d}-${h}`;
        dayCells[key] = cell;
        
        // Add click handler to open appointment modal with pre-filled date/time
        cell.addEventListener('click', (e) => {
          // Don't trigger if clicking on a booking card
          if (e.target.closest('.booking-card')) return;
          
          const dayIndex = parseInt(cell.dataset.day); // 0=Sunday, 1=Monday, ..., 6=Saturday
          const hour = parseInt(cell.dataset.hour);
          
          // Calculate the actual date for this cell (no offset, dayIndex is already 0-based for Sunday)
          const selectedDate = new Date(weekStart);
          selectedDate.setDate(weekStart.getDate() + dayIndex);
          
          // Format date as YYYY-MM-DD for HTML date input
          const yyyy = selectedDate.getFullYear();
          const mm = String(selectedDate.getMonth() + 1).padStart(2, '0');
          const dd = String(selectedDate.getDate()).padStart(2, '0');
          const dateStr = `${yyyy}-${mm}-${dd}`;
          
          // Format time as HH:MM for time input
          const timeStr = `${String(hour).padStart(2, '0')}:00`;
          
          // Open modal with pre-filled date and time
          openAppointmentModal({
            date: dateStr,
            startTime: timeStr
          });
        });
        
        row.appendChild(cell);
      }
      grid.appendChild(row);
    }

    // Fetch and display bookings
    fetchBookings(weekStart, dayCells);

    // Update Today button with current day number
    const todayBtn = document.getElementById('todayBtn');
    const todayNum = new Date().getDate();
    const todayText = todayBtn.querySelector('text');
    if (todayText) {
      todayText.textContent = todayNum;
    }

    // Controls
    todayBtn.onclick = () => renderWeek(new Date());
    document.getElementById('prevWeek').onclick = () => { const d = addDays(weekStart,-7); renderWeek(d); };
    document.getElementById('nextWeek').onclick = () => { const d = addDays(weekStart,7); renderWeek(d); };
    document.getElementById('refreshBtn').onclick = () => renderWeek(weekStart); // Refresh current week
  }

  async function refreshAdminCalendar() {
    // Reuse the existing calendar render logic (which also triggers the bookings fetch)
    try {
      if (typeof renderWeek === 'function') {
        renderWeek(weekStart || new Date());
        return;
      }

      // Fallback: reuse the existing refresh button handler if present
      const btn = document.getElementById('refreshBtn');
      if (btn) btn.click();
    } catch (e) {
      console.warn('[calendar] refreshAdminCalendar failed:', e);
    }
  }

  window.refreshAdminCalendar = refreshAdminCalendar;

  async function fetchBookings(weekStart, dayCells) {
    if (!window.supabaseClient) {
      console.error('❌ Supabase client not initialized');
      const calendar = document.getElementById('calendar');
      if (calendar) {
        calendar.innerHTML = '<div class="p-4 bg-red-50 text-red-800 rounded">❌ Supabase client not initialized. Check console for errors.</div>';
      }
      return;
    }

    const weekEnd = addDays(weekStart, 7);
    
    // Create consistent local date boundaries for query (avoid timezone drift)
    const weekStartLocal = new Date(weekStart);
    weekStartLocal.setHours(0, 0, 0, 0);
    
    const weekEndLocal = addDays(weekStartLocal, 7);
    weekEndLocal.setHours(0, 0, 0, 0);
    
    const weekStartIso = weekStartLocal.toISOString();
    const weekEndIso = weekEndLocal.toISOString();
    
    console.log('📅 Fetching bookings for week:', weekStartIso, 'to', weekEndIso);
    
    // First, fetch all services to create a lookup map
    const { data: services, error: servicesError } = await window.supabaseClient
      .from('service')
      .select('code, name, price_cents');
    
    const serviceMap = {};
    const servicePriceMap = {};
    if (services && !servicesError) {
      services.forEach(svc => {
        serviceMap[svc.code] = svc.name;
        servicePriceMap[svc.code] = svc.price_cents;
      });
    }
    
    // Helper: Get short service label
    const getServiceShortLabel = (serviceCode) => {
      switch (serviceCode) {
        case 'auto_60': return 'Auto - 1h';
        case 'auto_90': return 'Auto - 1.5h';
        case 'auto_120': return 'Auto - 2h';
        case 'manual_60': return 'Manual - 1h';
        case 'manual_90': return 'Manual - 1.5h';
        case 'manual_120': return 'Manual - 2h';
        case 'senior_auto_60': return 'Senior auto - 1h';
        case 'senior_manual_60': return 'Senior manual - 1h';
        default: return 'Lesson';
      }
    };
    
    // Helper: Generate red $ marker if unpaid
    const getPaymentMarker = (booking) => {
      return !booking.is_paid ? '<span class="payment-marker">$</span>' : '';
    };
    
    // Query bookings - exclude cancelled bookings
    const { data: bookings, error } = await window.supabaseClient
      .from('booking')
      .select('*')
      .gte('start_time', weekStartIso)
      .lt('start_time', weekEndIso)
      .neq('status', 'cancelled')
      .order('start_time');

    if (error) {
      console.error('❌ Error fetching bookings:', error);
      const weekRange = document.getElementById('weekRange');
      if (weekRange) {
        weekRange.innerHTML = `<span class="text-red-600">⚠️ Error loading bookings: ${error.message}</span>`;
      }
      return;
    }
    
    console.log(`✅ Found ${bookings?.length || 0} bookings for this week:`, bookings);

    if (!bookings || bookings.length === 0) {
      console.log('ℹ️ No bookings found for this week');

      // Update week range
      const weekRange = document.getElementById('weekRange');
      if (weekRange) {
        const formatShortDate = (date) => {
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = String(date.getFullYear()).slice(-2);
          return `${day}/${month}/${year}`;
        };
        weekRange.textContent = `Week: ${formatShortDate(weekStart)} - ${formatShortDate(addDays(weekStart, 6))}`;
      }

      // Show message beside buttons
      const msg = document.getElementById('noBookingsMsg');
      if (msg) {
        msg.textContent = "No bookings found for this week";
        msg.classList.remove("hidden");
      }

      return;
    } else {
      const msg = document.getElementById('noBookingsMsg');
      if (msg) msg.classList.add("hidden");
    }

    bookings.forEach(booking => {
      const start = new Date(booking.start_time);
      const end = new Date(booking.end_time);
      
      // Database stores TIMESTAMPTZ which JavaScript converts to local browser time
      // Use local time methods since the Date object is already in browser timezone
      const dayOfWeek = start.getDay();
      const hour = start.getHours();
      const key = `${dayOfWeek}-${hour}`;
      const cell = dayCells[key];
      
      // Calculate duration in hours for spanning multiple time slots
      const durationMs = end.getTime() - start.getTime();
      const durationHours = durationMs / (1000 * 60 * 60);
      
      console.log('📍 Placing booking:', { 
        booking_id: booking.id, 
        dayOfWeek, 
        hour, 
        key, 
        hasCell: !!cell, 
        is_booking: booking.is_booking,
        durationHours: durationHours.toFixed(2)
      });
      
      if (cell) {
        const bookingDiv = document.createElement('div');
        // JavaScript Date automatically converts to browser local time
        const time = start.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
        const endTime = end.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
        
        // Calculate exact pixel height based on duration
        // Each cell is 80px min-height on desktop, 48px on mobile
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const isTouchDevice = window.matchMedia('(hover: none)').matches || window.matchMedia('(pointer: coarse)').matches;
        // Determine actual rendered cell height (fallback to defaults)
        let cellHeight = isMobile ? 48 : 80;
        try {
          // Find any existing time slot cell to measure
          const sampleCell = document.querySelector('#weekGrid div.p-2.border.min-h-[80px]');
          if (sampleCell) {
            cellHeight = sampleCell.getBoundingClientRect().height || cellHeight;
          }
        } catch (e) { /* ignore measurement errors */ }
        // Desktop-only: subtract vertical padding to use the content height so 1h equals exactly one grid rectangle
        let effectiveCellHeight = cellHeight;
        if (!isMobile) {
          const cs = getComputedStyle(cell);
          const py = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
          effectiveCellHeight = Math.max(cellHeight - py, 0);
        }
        const heightPx = durationHours * effectiveCellHeight;
        
        // Decide detail level by visual height (works for 1h/1.5h/2h)
        let detailLevel = 1;                    // ~1h
        if (heightPx >= 120) detailLevel = 2;   // ~1.5h
        if (heightPx >= 160) detailLevel = 3;   // ~2h
        
        // Calculate minutes offset from the hour for precise positioning
        const minutes = start.getMinutes();
        const minuteOffset = (minutes / 60) * effectiveCellHeight;
        
        // Use is_booking flag to determine display type
        if (booking.is_booking) {
          // This is a booking with client information - show service name
          bookingDiv.className = 'booking-card text-xs border-l-2 border-blue-600 p-1 rounded absolute left-0 right-0 z-10';
          bookingDiv.style.backgroundColor = '#bfdbfe';
          bookingDiv.style.color = '#111827';
          const padAdjust = isMobile ? 4 : 8; // subtract internal card padding so the block visually fits one rectangle
          bookingDiv.style.height = `${Math.max(heightPx - padAdjust, 4)}px`;
          bookingDiv.style.top = `${minuteOffset}px`;
          
          const serviceName = serviceMap[booking.service_code] || 'Driving Lesson';
          const clientName = [booking.first_name, booking.last_name].filter(Boolean).join(' ') || 'Unknown Client';
          const statusValue = booking.status || 'confirmed';
          const statusLabel = statusValue === 'no_show' ? 'No Show' : (statusValue.charAt(0).toUpperCase() + statusValue.slice(1));
          const paidYesNo = booking.is_paid ? 'Yes' : 'No';
          
          // Get short service label
          const titleText = getServiceShortLabel(booking.service_code);
          
          // Build a compact location label for mobile
          let locationLabel = '';
          if (booking.pickup_location) {
            // Trim whitespace and remove trailing commas
            locationLabel = booking.pickup_location.trim().replace(/,+$/, '');
            // Truncate for small screens
            if (locationLabel.length > 26) {
              locationLabel = locationLabel.substring(0, 26) + '...';
            }
          }
          
          // Build HTML based on detail level
          let summaryHTML = '';
          let detailsHTML = '';
          
          if (detailLevel === 1) {
            // Compact view: desktop shows richer info; mobile minimal (transmission + duration + address)
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine = `${titleText}${paymentMarker}`;
            const shortTransmission = titleText.split(' - ')[0]; // Extract 'Auto' or 'Manual' for mobile
            // Duration implied by block height; omit address in desktop summary to reduce duplication.
            const desktopAddress = booking.pickup_location ? `📍 ${booking.pickup_location}` : '';
            summaryHTML = `
              <div class="desktop-only font-semibold" style="color:#111827;">${transmissionLine}</div>
              <!-- Desktop summary shows address only; client name removed for space -->
              <div class="desktop-only summary-address-l1" style="color:#374151;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;line-height:1.2;">${desktopAddress}</div>
              <div class="mobile-only font-semibold" style="color:#111827;">${shortTransmission}</div>
              <div class="mobile-only" style="display:none;color:#374151;">${locationLabel}</div>
            `;
            // Details order (both desktop + mobile): Auto/Manual, Address, Client, Mobile, Time, Status
            const addressInDetailsL1 = booking.pickup_location ? `<div class="text-xs mb-1 details-address-l1" style="color:#1e40af;">📍 ${booking.pickup_location}</div>` : '';
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#1e40af;">${transmissionLine}</div>
              ${addressInDetailsL1}
              <div class="text-sm font-semibold mb-1" style="color:#1e40af;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#1e40af;">📱 ${booking.mobile}</div>` : ''}
              <div class="text-xs mb-1 font-medium" style="color:#1e40af;">🕐 ${time} - ${endTime}</div>
              ${typeof booking.price_cents === 'number' ? `<div class="payment-toggle ${!booking.is_paid ? 'unpaid' : ''}">
                <span class="payment-label">Paid? ${paidYesNo} $${(booking.price_cents / 100).toFixed(0)}</span>
              </div>` : ''}
              <div class="mt-1">Status: ${statusLabel}</div>
            `;
          } else if (detailLevel === 2) {
            // 1.5 hours: Show service, client, address (2 lines), times, mobile. Status on hover.
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine2 = `${titleText}${paymentMarker}`;
            summaryHTML = `
              <div class="font-semibold" style="color:#111827;">${transmissionLine2}</div>
              <!-- Client name removed from web summary to prioritise address -->
              ${booking.pickup_location ? `<div class="text-xs summary-address" style="color:#374151;display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.3;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-xs mt-1 font-medium" style="color:#374151;">🕐 ${time} - ${endTime}</div>
              ${booking.mobile ? `<div class="text-xs summary-mobile" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
            `;
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${transmissionLine2}</div>
              ${booking.pickup_location ? `<div class="text-xs mb-1" style="color:#374151;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              ${typeof booking.price_cents === 'number' ? `<div class="payment-toggle ${!booking.is_paid ? 'unpaid' : ''}">
                <span class="payment-label">Paid? ${paidYesNo} $${(booking.price_cents / 100).toFixed(0)}</span>
              </div>` : ''}
              <div class="mt-1">Status: ${statusLabel}</div>
            `;
          } else {
            // 2+ hours: Show all info including status
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine3 = `${titleText}${paymentMarker}`;
            summaryHTML = `
              <div class="font-semibold" style="color:#111827;">${transmissionLine3}</div>
              <!-- Client name removed from web summary to prioritise address -->
              ${booking.pickup_location ? `<div class="text-xs summary-address" style="color:#374151;display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.3;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-xs mt-1 font-medium" style="color:#374151;">🕐 ${time} - ${endTime}</div>
              ${booking.mobile ? `<div class="text-xs summary-mobile" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              <div class="mt-1 desktop-only">Status: ${statusLabel}</div>
            `;
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${transmissionLine3}</div>
              ${booking.pickup_location ? `<div class="text-xs mb-1" style="color:#374151;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              ${typeof booking.price_cents === 'number' ? `<div class="payment-toggle ${!booking.is_paid ? 'unpaid' : ''}">
                <span class="payment-label">Paid? ${paidYesNo} $${(booking.price_cents / 100).toFixed(0)}</span>
              </div>` : ''}
              <div class="mt-1">Status: ${statusLabel}</div>
            `;
          }
          
          bookingDiv.innerHTML = `
            <div class="booking-card-content">
              <div class="booking-card-text">
                <div class="booking-summary">
                  ${summaryHTML}
                </div>
                ${detailsHTML && !isTouchDevice ? `<div class="booking-details">${detailsHTML}</div>` : ''}
              </div>
              <button class="booking-cancel-btn" data-booking-id="${booking.id}" data-google-event-id="${booking.google_event_id || ''}" title="Cancel booking" aria-label="Cancel booking">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="15" y1="9" x2="9" y2="15"></line>
                  <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
              </button>
            </div>
          `;
          
          // Add click handler to open edit modal for bookings
          const bookingCardText = bookingDiv.querySelector('.booking-card-text');
          if (bookingCardText) {
            bookingCardText.style.cursor = 'pointer';
            bookingCardText.addEventListener('click', (e) => {
              // Don't open modal if clicking interactive elements
              if (e.target.closest('.booking-cancel-btn')) return;
              e.stopPropagation();
              
              // Open edit booking modal with full booking data
              openEditBookingModal(booking);
            });
          }
        } else {
          // This is a regular calendar appointment - show title and times
          bookingDiv.className = 'booking-card text-xs border-l-2 border-gray-400 p-1 rounded absolute left-0 right-0 z-10';
          bookingDiv.style.backgroundColor = '#f3f4f6';
          bookingDiv.style.color = '#374151';
          const padAdjust2 = isMobile ? 4 : 8;
          bookingDiv.style.height = `${Math.max(heightPx - padAdjust2, 4)}px`;
          bookingDiv.style.top = `${minuteOffset}px`;
          
          const eventTitle = booking.event_title || 'Appointment';
          
          bookingDiv.innerHTML = `
            <div class="booking-card-content">
              <div class="booking-card-text">
                <div class="font-semibold" style="color:#374151;">${eventTitle}</div>
                <div class="booking-time" style="color:#374151;">${time} - ${endTime}</div>
              </div>
              <button class="booking-cancel-btn" data-booking-id="${booking.id}" data-google-event-id="${booking.google_event_id || ''}" data-event-title="${eventTitle}" title="Cancel event" aria-label="Cancel event">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="15" y1="9" x2="9" y2="15"></line>
                  <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
              </button>
            </div>
          `;
          
          // Add click handler to open edit modal for personal appointments
          const cardText = bookingDiv.querySelector('.booking-card-text');
          if (cardText) {
            cardText.style.cursor = 'pointer';
            cardText.addEventListener('click', (e) => {
              // Don't open modal if clicking the cancel button
              if (e.target.closest('.booking-cancel-btn')) return;
              
              // Extract date and time from ISO timestamp strings
              // booking.start_time and end_time are ISO strings like "2026-01-15T14:30:00+00:00"
              let dateStr = '';
              let startHHMM = '';
              let endHHMM = '';
              
              if (booking.start_time) {
                const startDate = new Date(booking.start_time);
                dateStr = formatDateForInputLocal(startDate); // YYYY-MM-DD (local)
                startHHMM = formatTimeForInput(startDate); // HH:MM (local)
              }
              
              if (booking.end_time) {
                const endDate = new Date(booking.end_time);
                endHHMM = formatTimeForInput(endDate); // HH:MM
              }
              
              // Open edit modal with booking data
              openEditPersonalAppointmentModal({
                googleEventId: booking.google_event_id,
                title: eventTitle,
                dateStr: dateStr,
                startHHMM: startHHMM,
                endHHMM: endHHMM,
                location: booking.pickup_location || ''
              });
            });
          }
        }
        
        cell.appendChild(bookingDiv);
      }
    });

    // Add event listeners to all cancel buttons
    document.querySelectorAll('.booking-cancel-btn').forEach(btn => {
      btn.addEventListener('click', async function(e) {
        e.stopPropagation(); // Prevent card expansion on mobile
        
        const bookingId = this.getAttribute('data-booking-id');
        const googleEventId = this.getAttribute('data-google-event-id');
        const eventTitle = this.getAttribute('data-event-title');
        
        // Check if this is a regular event (has event-title) or a booking
        const isRegularEvent = !!eventTitle;
        
        // Prepare confirmation message based on event type
        const confirmMessage = isRegularEvent 
          ? `Are you sure you want to cancel "${eventTitle}"?`
          : 'Are you sure you want to cancel this booking? This action cannot be undone.';
        
        // handleBookingCancellation will show confirmation via cancelWithConfirmation
        await handleBookingCancellation(this, bookingId, null, googleEventId, confirmMessage);
      });
    });
    
    // Wrap mobile setup in a function so it can be called on resize
    function setupMobileInteractions() {
      const isMobile = window.matchMedia('(max-width: 768px)').matches;

      if (!isMobile) {
        return;
      }

      // Create backdrop element
      let backdrop = document.getElementById('booking-backdrop');
      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.id = 'booking-backdrop';
        backdrop.className = 'booking-backdrop';
        document.body.appendChild(backdrop);
      }

      const cards = document.querySelectorAll('#section-calendar .booking-card');

      if (cards.length === 0) {
        // No cards yet - calendar may still be loading, this is normal
        return;
      }

      // Function to close all active bookings
      const closeAllBookings = () => {
        cards.forEach(c => {
          c.classList.remove('booking-active');
          // Temporarily disable pointer events to clear hover state
          c.style.pointerEvents = 'none';
          setTimeout(() => { c.style.pointerEvents = ''; }, 10);
        });
        backdrop.classList.remove('active');
        // Remove any injected close buttons to restore compact layout
        document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
      };

      // Remove existing backdrop listeners by replacing it
      const newBackdrop = backdrop.cloneNode(true);
      backdrop.parentNode.replaceChild(newBackdrop, backdrop);
      backdrop = newBackdrop;

      // Click backdrop to close
      backdrop.addEventListener('click', closeAllBookings);

      // Click calendar grid to close popup - use event delegation
      const calendar = document.getElementById('calendar');
      if (calendar) {
        // Remove old flag to allow re-adding listener
        if (calendar.dataset.mobileListenerAdded) {
          console.log('[mobile] Calendar listener already exists, skipping');
        } else {
          calendar.dataset.mobileListenerAdded = 'true';
          calendar.addEventListener('click', (e) => {
            // Only close if clicking the calendar itself or a grid cell, not a booking card
            if (!e.target.closest('.booking-card')) {
              const backdrop = document.getElementById('booking-backdrop');
              if (backdrop && backdrop.classList.contains('active')) {
                const cards = document.querySelectorAll('#section-calendar .booking-card');
                cards.forEach(c => {
                  c.classList.remove('booking-active');
                  // Temporarily disable pointer events to clear hover state
                  c.style.pointerEvents = 'none';
                  setTimeout(() => { c.style.pointerEvents = ''; }, 10);
                });
                backdrop.classList.remove('active');
                document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
              }
            }
          });
        }
      }

      // Clone each card to remove old event listeners, then add new ones
      cards.forEach((card, index) => {
        // Check if this card already has the listener
        if (card.dataset.mobileListenerAdded) {
          console.log('[mobile] Card', index, 'already has listener, skipping');
          return;
        }

        card.dataset.mobileListenerAdded = 'true';
        card.addEventListener('click', (e) => {
          console.log('[mobile] Card clicked');
          // Ignore clicks on the close button or cancel button
          if (e.target.closest('.booking-close-btn')) return;
          if (e.target.closest('.booking-cancel-btn')) return;

          e.stopPropagation();

          // For bookings on mobile, open Edit modal only (no booking-active expansion)
          const cancelBtn = card.querySelector('.booking-cancel-btn');
          const isRegularEvent = !!(cancelBtn && cancelBtn.getAttribute('data-event-title'));
          if (!isRegularEvent) {
            const bookingId = cancelBtn ? cancelBtn.getAttribute('data-booking-id') : null;
            const bookingData = bookingId ? bookings.find(b => String(b.id) === String(bookingId)) : null;
            closeAllBookings();
            if (bookingData) {
              openEditBookingModal(bookingData);
            }
            return;
          }

          // Close others
          const allCards = document.querySelectorAll('#section-calendar .booking-card');
          allCards.forEach(c => {
            if (c !== card) c.classList.remove('booking-active');
          });

          // Toggle this one
          const isOpening = !card.classList.contains('booking-active');
          card.classList.toggle('booking-active');
          console.log('[mobile] Card toggled, isOpening:', isOpening);

          // Show/hide backdrop
          if (isOpening) {
            backdrop.classList.add('active');

            // Add close button if not already present
            if (!card.querySelector('.booking-close-btn')) {
              const closeBtn = document.createElement('button');
              closeBtn.className = 'booking-close-btn';
              closeBtn.innerHTML = '×';
              closeBtn.setAttribute('aria-label', 'Close');
              closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeAllBookings();
              });
              card.appendChild(closeBtn);
            }
          } else {
            backdrop.classList.remove('active');
            // Remove close button on closing this card
            const btn = card.querySelector('.booking-close-btn');
            if (btn) btn.remove();
          }
        });
      });
    }

    // Mobile: tap a blue block to toggle details
    setupMobileInteractions();

    // Handle window resize to clean up states when switching between desktop/mobile
    let resizeTimeout;
    let wasMobile = window.matchMedia('(max-width: 768px)').matches;

    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const cards = document.querySelectorAll('#section-calendar .booking-card');
        const backdrop = document.getElementById('booking-backdrop');

        if (!isMobile) {
          // Switching to desktop: clean up mobile popup states
          cards.forEach(c => {
            c.classList.remove('booking-active');
            // Remove mobile listener flag so it can be re-added when switching back to mobile
            delete c.dataset.mobileListenerAdded;
          });
          if (backdrop) backdrop.classList.remove('active');
          document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());

          // Clear calendar listener flag
          const calendar = document.getElementById('calendar');
          if (calendar) delete calendar.dataset.mobileListenerAdded;

          // If we just switched from mobile to desktop, refresh the calendar to recalculate heights
          if (wasMobile && !isMobile) {
            console.log('[calendar] Switched from mobile to desktop - refreshing calendar');
            renderWeek(weekStart);
          }
        } else if (wasMobile !== isMobile) {
          // Switching to mobile: re-setup mobile interactions and clean up
          console.log('[calendar] Switched from desktop to mobile - setting up mobile interactions');
          document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
          if (backdrop) backdrop.classList.remove('active');

          // Force remove hover states by temporarily disabling pointer events
          cards.forEach(c => {
            c.style.pointerEvents = 'none';
          });
          setTimeout(() => {
            cards.forEach(c => {
              c.style.pointerEvents = '';
            });
          }, 50);

          // Re-setup mobile interactions for existing cards
          setupMobileInteractions();
        }

        // Update the previous state
        wasMobile = isMobile;
      }, 100);
    });
    
    // Helper function to get current admin email
    async function getAdminEmail() {
      if (!window.supabaseClient) {
        console.error('[calendar] getAdminEmail: supabaseClient not available');
        return null;
      }
      
      try {
        const { data: { session } } = await window.supabaseClient.auth.getSession();
        return session?.user?.email || null;
      } catch (error) {
        console.error('[calendar] Error getting admin email:', error);
        return null;
      }
    }
    
    // Helper function to handle booking cancellation (used by both cancel button and status change)
    async function handleBookingCancellation(element, bookingId, originalStatus = null, googleEventId = null, confirmMessage = null) {
      // Get google event ID from element if not provided
      if (!googleEventId && element.hasAttribute('data-google-event-id')) {
        googleEventId = element.getAttribute('data-google-event-id');
      }
      
      // Get admin email
      const adminEmail = await getAdminEmail();
      
      // Use the unified cancellation function
      if (window.GoogleCalendar && window.GoogleCalendar.cancelWithConfirmation) {
        await window.GoogleCalendar.cancelWithConfirmation({
          bookingId: bookingId,
          googleEventId: googleEventId,
          cancelledBy: adminEmail,
          triggerElement: element,
          confirmMessage: confirmMessage, // Use custom message if provided
          confirmTitle: 'Cancel appointment',
          showSuccessMessage: false, // Admin calendar refresh provides visual feedback
          onSuccess: async () => {
            // Refresh the calendar after successful cancellation
            console.log('[calendar] Refreshing calendar view...');
            setTimeout(() => renderWeek(weekStart), 500);
          },
          onCancel: () => {
            // User aborted - revert dropdown to original status
            if (element.tagName === 'SELECT' && originalStatus) {
              element.value = originalStatus;
            }
          },
          onError: (error) => {
            // If this is a status dropdown and we have an original status, revert to it
            if (element.tagName === 'SELECT' && originalStatus) {
              element.value = originalStatus;
            }
          }
        });
      } else {
        console.error('[calendar] GoogleCalendar.cancelWithConfirmation not available');
        alert('Cancellation feature not available. Please refresh the page.');
      }
    }
    
    // Helper function to update booking status
    async function updateBookingStatus(selectElement, bookingId, newStatus, originalStatus) {
      const originalBg = selectElement.style.backgroundColor;
      selectElement.style.backgroundColor = '#fef3c7'; // yellow-100
      selectElement.disabled = true;
      
      try {
        // If cancelling, use Google Calendar integration with admin email tracking
        if (newStatus === 'cancelled') {
          const googleEventId = selectElement.getAttribute('data-google-event-id');
          await handleBookingCancellation(selectElement, bookingId, originalStatus, googleEventId);
          return; // handleBookingCancellation manages the rest
        }
        
        // For non-cancellation status changes, update database directly
        const { error } = await window.supabaseClient
          .from('booking')
          .update({ status: newStatus })
          .eq('id', bookingId);
        
        if (error) {
          console.error('[calendar] Error updating status:', error);
          selectElement.value = originalStatus;
          alert('Failed to update booking status: ' + error.message);
          selectElement.style.backgroundColor = '#fee2e2'; // red-100
        } else {
          console.log('[calendar] ✅ Status updated successfully');
          selectElement.setAttribute('data-original-status', newStatus);
          selectElement.style.backgroundColor = '#d1fae5'; // green-100
          
          setTimeout(() => {
            selectElement.style.backgroundColor = originalBg;
          }, 1000);
        }
      } catch (err) {
        console.error('[calendar] Exception updating status:', err);
        selectElement.value = originalStatus;
        alert('Failed to update booking status: ' + err.message);
        selectElement.style.backgroundColor = '#fee2e2'; // red-100
      } finally {
        selectElement.disabled = false;
      }
    }
  }

  // Initialize calendar when this partial loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => renderWeek(new Date()));
  } else {
    renderWeek(new Date());
  }
})();
</script>
