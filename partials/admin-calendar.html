<!-- Admin Calendar Section -->
<script src="assets/js/googleCalendar.js?v=3"></script>
<style>
  /* Scoped styles for calendar bookings */
  #section-calendar .booking-card {
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: visible;
  }
  
  #section-calendar .booking-card .booking-time {
    font-weight: 600;
  }
  
  /* Compact view - hide details by default */
  #section-calendar .booking-card .booking-details {
    display: none;
  }
  
  /* Expanded view on hover - show full details - DESKTOP ONLY */
  @media (min-width: 769px) {
    #section-calendar .booking-card:hover {
      z-index: 50 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: scale(1.02);
      height: auto !important;
      min-height: fit-content !important;
      overflow: visible;
    }
    
    #section-calendar .booking-card:hover .booking-details {
      display: block;
    }
    /* Desktop hover: hide entire summary when details are shown to avoid duplicates */
    #section-calendar .booking-card:hover .booking-summary {
      display: none !important;
    }
  }
  
  /* Compact summary styling */
  #section-calendar .booking-summary {
    line-height: 1.2;
  }
  
  #section-calendar .booking-summary .booking-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* Cancel button styling */
  #section-calendar .booking-cancel-btn {
      width: 18px;
      height: 18px;
      padding: 0;                       /* tightest fit */
      border-radius: 50%;               /* perfect circle */
      background: transparent;
      color: #dc2626;                   /* normal soft red */
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease, color 0.15s ease;
      margin-left: auto;
      margin-right: -4px;
      flex-shrink: 0;                   /* prevent shrinking */
  }

  #section-calendar .booking-cancel-btn:hover {
      background: rgba(220, 38, 38, 0.10); /* tighter, softer halo */
      color: #b91c1c;                      /* subtle darkening */
  }

  #section-calendar .booking-cancel-btn svg {
    display: block;
  }
  
  @media (max-width: 768px) {
    /* Hide red cancel X on collapsed cards in the grid */
    #section-calendar .booking-card:not(.booking-active) .booking-cancel-btn {
      display: none !important;
    }

    /* Show it again on the expanded mobile popup */
    #section-calendar .booking-card.booking-active .booking-cancel-btn {
      display: inline-flex !important;
    }
  }


  /* Wrapper for button and content to use flexbox */
  #section-calendar .booking-card-content {
    display: flex;
    align-items: flex-start;
    gap: 2px;
  }
  
  #section-calendar .booking-card-text {
    flex: 1;
    min-width: 0;
  }
  
  #section-calendar .booking-cancel-btn {
    align-self: flex-start;
    margin-top: 0px;
  }
  
  /* Show cancel button always for now */
  #section-calendar .booking-card .booking-cancel-btn {
    display: inline-flex;
  }
  
  /* Ensure status dropdown is always visible in expanded state */
  #section-calendar .booking-card .booking-status-select {
    margin-top: 0.25rem;
  }
  
  /* Red $ marker for payment required bookings */
  #section-calendar .payment-marker {
    color: #ff4d4d;
    font-weight: 700;
    margin-left: 4px;
    font-size: 0.9em;
  }
  
  /* Payment toggle checkbox and label */
  #section-calendar .payment-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    margin: 4px 0;
  }
  
  #section-calendar .payment-toggle-checkbox {
    transform: scale(1.0);
    cursor: pointer;
  }
  
  #section-calendar .payment-label {
    font-weight: 600;
  }
  
  /* Red warning when payment not yet received */
  #section-calendar .payment-toggle.unpaid .payment-label {
    color: #ff4d4d;
  }
  
  /* Ensure header row and time column are visible on dark background */
  #section-calendar .calendar-header {
    color: #111827 !important;
    background-color: #f3f4f6 !important;
  }
  #section-calendar .calendar-time-cell {
    color: #111827 !important;
    background-color: #f9fafb !important;
    padding: 4px 6px; /* Tighter vertical spacing for mobile */
    position: sticky;
    left: 0;
    z-index: 10;
  }
  
  /* Hide mobile-only elements on desktop */
  #section-calendar .mobile-only {
    display: none;
  }
  
  /* Tighter row height for mobile */
  #section-calendar #weekGrid > div > div {
    min-height: 56px; /* down from 80px */
  }
  
  /* Fix for header time cell */
  #section-calendar .calendar-header:first-child {
    position: sticky;
    left: 0;
    z-index: 20;
    background-color: #f3f4f6 !important;
  }
  
  /* Calendar grid cells */
  #section-calendar #weekGrid > div {
    background-color: white !important;
    border-color: #e5e7eb !important;
  }
  
  /* Calendar title and text */
  #section-calendar h2,
  #section-calendar .text-sm {
    color: #111827 !important;
  }
  
  /* Calendar navigation buttons – reuse global btn/btn-primary colours */
  #section-calendar .calendar-nav-btn {
    /* size tweaks only */
    height: 32px;
    min-width: 32px;
    padding: 0.25rem 0.5rem;
    line-height: 1;
    border-radius: 0.5rem; /* match other buttons */
    font-weight: 500;
  }

  /* Make icon-based button match text buttons */
  #section-calendar .calendar-nav-btn svg {
    width: 20px;
    height: 20px;
    display: block;
  }
  
  /* Mobile scroll improvements */
  #section-calendar #calendar {
    overflow-x: auto;
    overflow-y: auto;
  }
  
  /* Desktop: wider columns */
  #section-calendar #weekGrid {
    min-width: auto; /* Allow mobile to shrink */
  }
  
  /* Personal appointment modal */
  .admin-modal-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(15, 23, 42, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
  }

  .admin-modal-backdrop.hidden {
    display: none;
  }

  /* Appointment modal layout */
  .admin-modal {
    background-color: #0b1727;           /* same dark panel as admin */
    border: 1px solid #1E40AF;          /* subtle blue border */
    border-radius: 0.75rem;
    padding: 0.75rem 1.5rem 1.5rem;     /* ↓ smaller top padding */
    max-width: 480px;
    width: 100%;
    box-shadow: 0 20px 25px rgba(15, 23, 42, 0.5);
  }

  .admin-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;              /* ↓ less space below header */
  }

  .admin-modal-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin: 0;                          /* remove extra h2 margin */
    color: #e5e7eb;
  }

  /* Make sure calendar-wide h2 colour does not override the title */
  #section-calendar .admin-modal-title {
    color: #e5e7eb !important;
  }

  .admin-modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #9ca3af;
    cursor: pointer;
  }

  .admin-modal-close:hover {
    color: #ffffff;
  }

  .admin-modal-body .form-group {
    margin-bottom: 0.75rem;
  }

  .admin-modal-body label {
    display: block;
    font-size: 0.875rem;
    margin-bottom: 0.25rem;
    color: #e5e7eb;
  }

  /* Override section-calendar inline color for all modal labels */
  #section-calendar .admin-modal-body label {
    color: #e5e7eb !important;
  }

  /* Ensure radio button and checkbox labels are visible - override section-calendar inline style */
  #section-calendar .admin-modal-body label span {
    color: #e5e7eb !important;
  }

  #section-calendar .admin-modal-body .inline-options label {
    display: flex !important;
    color: #e5e7eb !important;
  }

  #section-calendar .admin-modal-body .inline-options label span {
    color: #e5e7eb !important;
  }

  /* Ensure help text is visible */
  #section-calendar .admin-modal-body p {
    color: #9ca3af !important;
  }

  #section-calendar .admin-modal-body .text-gray-400 {
    color: #9ca3af !important;
  }

  /* Error messages must stay red */
  #section-calendar .admin-modal-body p.text-red-500 {
    color: #ef4444 !important;
  }

  .admin-modal-body .form-input {
    width: 100%;
    padding: 0.45rem 0.6rem;
    border-radius: 0.375rem;
    border: 1px solid #1f2937;
    background-color: #020617;
    color: #e5e7eb;
    font-size: 0.9rem;
  }

  .admin-modal-body .form-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 1px #3b82f6;
  }

  .admin-modal-body .form-row {
    display: flex;
    gap: 0.75rem;
  }

  .admin-modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 1rem;
  }
  
  /* Visible scrollbar for mobile */
  #section-calendar #calendar::-webkit-scrollbar {
    height: 8px;
    width: 8px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 4px;
  }
  
  #section-calendar #calendar::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
  }
  
  /* Firefox scrollbar */
  #section-calendar #calendar {
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 #f1f5f9;
  }
  
  /* Mini spinner for new booking status */
  #section-calendar .mini-spinner {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid rgba(107, 114, 128, 0.35);
    border-top-color: rgba(107, 114, 128, 1);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    vertical-align: -2px;
    margin-right: 8px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* Mobile: narrower columns so all 7 days fit */
  @media (max-width: 768px) {
  /* Always hide elements marked web-only on mobile (even when expanded) */
  #section-calendar .web-only { display: none !important; }
    /* Hide desktop-only content in compact blue blocks */
    #section-calendar .booking-card .desktop-only {
      display: none !important;
    }
    
    /* Show mobile-only content */
    #section-calendar .booking-card .mobile-only {
      display: block !important;
    }
    
    /* In expanded view, show everything */
    #section-calendar .booking-card.booking-active .desktop-only {
      display: block !important;
    }
    
    #section-calendar #weekGrid {
      grid-template-columns: 35px repeat(7, 1fr) !important;
      min-width: 100% !important; /* Remove forced scroll, fit to screen */
    }

    #section-calendar .calendar-header,
    #section-calendar .calendar-time-cell {
      padding: 2px 1px;
      font-size: 9px;
      line-height: 1.0;
      text-align: center;
    }

    /* Slightly shorter rows to reduce vertical scroll */
    #section-calendar #weekGrid > div > div {
      min-height: 48px;
    }
    
    /* Reduce cell padding for tighter fit */
    #section-calendar #weekGrid > div > div {
      padding: 1px;
    }
    
    /* Mobile: compact blocks, expand on tap */
    /* Default: show as a simple bar with name/suburb */
    #section-calendar .booking-card {
      /* Colors set via inline styles for booking vs non-booking */
      border-left: none !important;
      border-radius: 2px;
      padding: 2px 3px !important;
      overflow: hidden;
      font-size: 9px !important;
      line-height: 1.2;
      font-weight: 500;
    }
    
    /* Hide cancel button in compact mobile view to prevent accidental presses */
    #section-calendar .booking-card .booking-cancel-btn {
      display: none !important;
    }
    
    /* Show cancel button in expanded mobile popup */
    #section-calendar .booking-card.booking-active .booking-cancel-btn {
      display: inline-flex !important;
    }
    
    /* Show minimal info in compact view */
    #section-calendar .booking-card .booking-summary {
      display: block !important;
    }
    
    /* Hide detailed info by default */
    #section-calendar .booking-card .booking-details {
      display: none;
    }

    /* Expanded: centered modal wider for readability */
    #section-calendar .booking-card.booking-active {
      /* Background color set via inline styles (blue-200 for bookings, gray-100 for non-bookings) */
      border-left: 2px solid #3b82f6 !important;
      padding: 12px 16px !important;
      z-index: 50 !important;
      overflow: visible;
      position: fixed !important;
      left: 50% !important;
      top: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 90vw !important;
      max-width: 420px !important;
      height: auto !important;
      max-height: 80vh !important;
      overflow-y: auto !important;
      box-shadow: 0 14px 48px rgba(0,0,0,0.35) !important;
      font-size: 13px !important;
      border-radius: 12px !important;
    }
    
    /* Text color set via inline styles (dark blue for bookings, dark gray for non-bookings) */
    #section-calendar .booking-card.booking-active .booking-name { 
      font-weight: 600;
    }
    /* Hide mobile summary when expanded to avoid duplication (details remain visible) */
    #section-calendar .booking-card.booking-active .booking-summary { display: none !important; }
    
    /* Move cancel button left on mobile expanded view to avoid overlap with close X */
    #section-calendar .booking-card.booking-active .booking-cancel-btn { 
      margin-right: 24px !important; 
    }
    
    /* Close button for mobile modal (neutral gray, overlays content) */
    #section-calendar .booking-close-btn {
      position: absolute;
      top: 10px;           /* align with cancel button */
      right: 10px;
      width: 18px;
      height: 18px;
      background: transparent;  /* no fill */
      color: #6b7280 !important; /* gray-500 */
      border: none;
      border-radius: 50%;       /* still clickable circle area */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: bold;
      line-height: 0.75;
      z-index: 60;
    }
    
    #section-calendar .booking-close-btn:hover {
      background: rgba(0,0,0,0.04);
      color: #374151 !important; /* gray-700 */
    }

    #section-calendar .booking-card.booking-active .booking-details {
      display: block;
    }
    
    /* Backdrop for closing modal */
    #section-calendar .booking-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 45;
    }
    
    #section-calendar .booking-backdrop.active {
      display: block;
    }

    /* Ensure appointment type labels are visible in dark modal */
    .appointment-type-options span {
      color: #ffffff !important;
    }
  }
  
</style>
<section id="section-calendar" class="section-content bg-white border rounded-2xl shadow-sm p-5" style="background-color: white !important; color: #111827 !important;">
  <!-- Week range + navigation -->
  <div class="flex items-center justify-between mb-3" role="group" aria-label="Calendar navigation">
    <div class="flex items-center gap-3">
      <span id="weekRange" class="text-base sm:text-lg font-bold text-blue-600">
        Week: 09/11/25 - 15/11/25
      </span>
      <div class="flex items-center gap-2">
        <button id="prevWeek" class="btn btn-primary-light calendar-nav-btn !px-2 !py-1" aria-label="Previous week">←</button>
        <button id="nextWeek" class="btn btn-primary calendar-nav-btn !px-2 !py-1" aria-label="Next week">→</button>
        <button id="todayBtn" class="btn btn-outline-blue calendar-nav-btn !px-2 !py-1" title="Today" aria-label="Jump to today">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8"  y1="2" x2="8"  y2="6"></line>
            <line x1="3"  y1="10" x2="21" y2="10"></line>
            <text x="12" y="16" text-anchor="middle" font-size="9" font-weight="bold" fill="currentColor">{{DAY}}</text>
          </svg>
        </button>
        <button id="refreshBtn" class="btn btn-outline-blue calendar-nav-btn !px-2 !py-1" title="Refresh calendar" aria-label="Refresh calendar">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="23 4 23 10 17 10"></polyline>
            <polyline points="1 20 1 14 7 14"></polyline>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg>
        </button>
        <button id="btn-new-appointment" class="btn btn-primary btn-sm ml-2" title="New appointment">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
            <line x1="12" y1="14" x2="12" y2="18"></line>
            <line x1="10" y1="16" x2="14" y2="16"></line>
          </svg>
          <span class="hidden sm:inline ml-1">New appointment</span>
        </button>
        <span id="newBookingStatus" class="ml-3 text-sm text-gray-500 hidden" aria-live="polite"></span>
      </div>
    </div>
  </div>
  
  <!-- No bookings message - displayed below navigation -->
  <div id="noBookingsMsg" class="text-blue-500 font-semibold text-center mb-3 hidden">
    No bookings found for this week
  </div>

  <div id="calendar" class="overflow-auto max-h-[600px] relative">
    <div id="weekGrid" class="grid grid-cols-8 text-sm" style="grid-template-columns: 80px repeat(7, minmax(120px, 1fr));"></div>
  </div>

  <!-- Add Appointment Modal -->
  <div id="appointment-modal-backdrop" class="admin-modal-backdrop hidden">
    <div class="admin-modal">
      <div class="admin-modal-header">
        <h2 class="admin-modal-title">New appointment</h2>
        <button type="button" id="appointment-modal-close" class="admin-modal-close">&times;</button>
      </div>


      <form id="appointment-form" class="admin-modal-body">
        <!-- Appointment Type -->
        <div class="form-group">
          <label>Type<span class="text-red-500">*</span></label>
          <div class="inline-options flex gap-4 appointment-type-options">
            <label class="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="appointmentType" value="booking" checked class="cursor-pointer">
              <span class="text-sm text-white">Lesson booking</span>
            </label>
            <label class="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="appointmentType" value="personal" class="cursor-pointer">
              <span class="text-sm text-white">Personal appointment</span>
            </label>
          </div>
        </div>

        <!-- Service (Lesson bookings only) -->
        <div id="booking-service-field" class="form-group" style="display:block;">
          <label for="bookingService">Service<span class="text-red-500">*</span></label>
          <select id="bookingService" class="form-input">
            <option value="">Select a service...</option>
            <!-- Options populated dynamically from SITE_CONFIG.BOOKING_CATEGORIES -->
          </select>
          <p id="bookingService-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Title (Personal appointments only) -->
        <div id="personal-title-field" class="form-group" style="display:none;">
          <label for="appt-title">Title<span class="text-red-500">*</span></label>
          <input id="appt-title" name="title" type="text" class="form-input" />
          <p id="appt-title-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Date -->
        <div class="form-group">
          <label for="appt-date">Date<span class="text-red-500">*</span></label>
          <input id="appt-date" name="date" type="date" class="form-input" style="max-width: 200px;" />
          <p id="appt-date-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Time range -->
        <div class="form-row">
          <div class="form-group">
            <label for="appt-start">Start time<span class="text-red-500">*</span></label>
            <input id="appt-start" name="startTime" type="time" class="form-input" />
            <p id="appt-start-error" class="text-xs text-red-500 mt-1 hidden"></p>
          </div>
          <div class="form-group">
            <label for="appt-end" id="appt-end-label">End time</label>
            <input id="appt-end" name="endTime" type="time" class="form-input" />
          </div>
        </div>

        <!-- Location (Personal appointments only) -->
        <div id="personal-location-field" class="form-group" style="display:none;">
          <label for="appt-location">Location<span class="text-gray-400"> (optional)</span></label>
          <input id="appt-location" name="location" type="text" class="form-input" />
          <p id="appt-location-error" class="text-xs text-red-500 mt-1 hidden"></p>
        </div>

        <!-- Booking-specific fields -->
        <div id="bookingFields" class="mt-3" style="display:block;">
          <!-- Client mode -->
          <div class="form-group">
            <label>Client<span class="text-red-500">*</span></label>
            <div class="inline-options flex gap-4">
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="clientMode" value="existing" checked class="cursor-pointer">
                <span class="text-sm text-gray-200">Existing</span>
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="clientMode" value="new" class="cursor-pointer">
                <span class="text-sm text-gray-200">New</span>
              </label>
            </div>
          </div>

          <!-- Existing client -->
          <div id="existingClientFields">
            <div class="form-group">
              <label for="existingClientSelect">Select client<span class="text-red-500">*</span></label>
              <select id="existingClientSelect" class="form-input">
                <option value="">Loading clients...</option>
              </select>
              <p id="existingClientSelect-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
          </div>

          <!-- New client -->
          <div id="newClientFields" style="display:none;">
            <div class="form-group">
              <label for="newClientFirstName">First name<span class="text-red-500">*</span></label>
              <input id="newClientFirstName" type="text" class="form-input">
              <p id="newClientFirstName-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientLastName">Last name<span class="text-red-500">*</span></label>
              <input id="newClientLastName" type="text" class="form-input">
              <p id="newClientLastName-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientEmail">Email address<span class="text-red-500">*</span></label>
              <input id="newClientEmail" type="email" class="form-input">
              <p id="newClientEmail-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
            <div class="form-group">
              <label for="newClientMobile">Mobile<span class="text-red-500">*</span></label>
              <input id="newClientMobile" type="text" class="form-input" placeholder="e.g. 0412 345 678">
              <p id="newClientMobile-error" class="text-xs text-red-500 mt-1 hidden"></p>
            </div>
          </div>

          <!-- Pickup -->
          <div class="form-group">
            <label for="bookingPickupLocation">Pickup address<span class="text-red-500">*</span></label>
            <input id="bookingPickupLocation" type="text" class="form-input" placeholder="e.g. 123 Main St, Melbourne VIC 3000">
            <p id="bookingPickupLocation-error" class="text-xs text-red-500 mt-1 hidden"></p>
            
            <!-- Suggestion button (hidden by default) -->
            <button type="button" id="bookingPickupLocation-suggestion" class="hidden mt-2 w-full rounded-md border border-blue-300 bg-blue-50 px-3 py-2 text-left text-sm text-blue-900 hover:bg-blue-100 cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-400">
              <div class="font-semibold mb-0.5 text-xs text-blue-800">Suggested address (tap to use)</div>
              <div class="truncate text-blue-700" id="bookingPickupLocation-suggestion-text"></div>
            </button>
          </div>

          <!-- Payment required -->
          <div class="form-group">
            <label class="flex items-center gap-2 cursor-pointer">
              <input type="checkbox" id="bookingPaymentRequired" checked class="cursor-pointer">
              <span class="text-sm">Payment required?</span>
            </label>
            <p class="text-xs text-gray-400 mt-1">Uncheck when payment made by cash, direct transfer, etc</p>
          </div>
        </div>

        <div class="admin-modal-footer">
          <button type="button" id="appointment-cancel" class="btn btn-secondary btn-sm">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary btn-sm" id="appointment-save">
            Save
          </button>
        </div>
      </form>
    </div>
  </div>
</section>

<script>
(function() {
  // Calendar logic
  function addDays(d, n) { const r = new Date(d); r.setDate(r.getDate() + n); return r; }
  let weekStart = new Date();

  // Service duration configuration (in minutes) – populated from config
  const SERVICE_DURATIONS = {};

  // Helper: Round time to next 15 minutes
  function roundToNext15Minutes(date = new Date()) {
    const d = new Date(date);
    const minutes = d.getMinutes();
    const remainder = minutes % 15;
    const offset = remainder === 0 ? 0 : 15 - remainder;
    d.setMinutes(minutes + offset, 0, 0);
    return d;
  }

  // Helper: Format time as HH:MM for time input
  function formatTimeForInput(date) {
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  // Helper: Add minutes to a time string (HH:MM format)
  function addMinutesToTime(timeString, date, minutesToAdd) {
    if (!timeString || !date) return '';
    const [hours, mins] = timeString.split(':').map(Number);
    const d = new Date(date);
    d.setHours(hours, mins, 0, 0);
    d.setMinutes(d.getMinutes() + minutesToAdd);
    return formatTimeForInput(d);
  }

  // Modal handling for personal appointments
  const btnNewAppointment = document.getElementById("btn-new-appointment");
  const apptBackdrop = document.getElementById("appointment-modal-backdrop");
  const apptForm = document.getElementById("appointment-form");
  const apptCloseBtn = document.getElementById("appointment-modal-close");
  const apptCancelBtn = document.getElementById("appointment-cancel");
  let formHasChanges = false;

  function openAppointmentModal(defaults = {}) {
    // Reset form to defaults
    apptForm.reset();
    
    // Reset appointment type to "booking" (default)
    const bookingRadio = document.querySelector('input[name="appointmentType"][value="booking"]');
    if (bookingRadio) bookingRadio.checked = true;
    
    // Reset client mode to "existing" (default)
    const existingClientRadio = document.querySelector('input[name="clientMode"][value="existing"]');
    if (existingClientRadio) existingClientRadio.checked = true;
    
    // Show/hide fields based on default type (booking)
    document.getElementById('personal-title-field').style.display = 'none';
    document.getElementById('personal-location-field').style.display = 'none';
    document.getElementById('booking-service-field').style.display = 'block';
    document.getElementById('bookingFields').style.display = 'block';
    document.getElementById('existingClientFields').style.display = 'block';
    document.getElementById('newClientFields').style.display = 'none';
    
    // Set end time field to readonly for bookings
    const endTimeInput = document.getElementById('appt-end');
    endTimeInput.readOnly = true;
    document.getElementById('appt-end-label').innerHTML = 'End time';
    
    // Default date to today if not provided
    const today = new Date();
    const dateStr = defaults.date || today.toISOString().split('T')[0];
    
    // Default start time to next 15 minutes if not provided and date is today
    let startTime = defaults.startTime || '';
    if (!startTime && dateStr === today.toISOString().split('T')[0]) {
      const rounded = roundToNext15Minutes();
      startTime = formatTimeForInput(rounded);
    }
    
    // Populate defaults
    document.getElementById("appt-title").value = defaults.title || "";
    document.getElementById("appt-date").value = dateStr;
    document.getElementById("appt-start").value = startTime;
    document.getElementById("appt-end").value = defaults.endTime || "";
    document.getElementById("appt-location").value = defaults.location || "";

    // Clear all validation errors
    clearApptError("appt-title");
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("appt-location");
    clearApptError("bookingPickupLocation");
    
    // Hide pickup suggestion on fresh modal open
    hidePickupSuggestion();

    // Calculate initial end time for booking if service is selected
    updateBookingEndTime();

    formHasChanges = false; // Reset change tracking
    apptBackdrop.classList.remove("hidden");
  }

  function closeAppointmentModal(force = false) {
    // Check if there are unsaved changes
    if (!force && formHasChanges) {
      if (window.Modal && window.Modal.confirm) {
        window.Modal.confirm(
          "Do you want to save your changes?",
          () => {
            // User clicked Yes - trigger form submission
            apptForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
          },
          () => {
            // User clicked No - close without saving
            apptBackdrop.classList.add("hidden");
            apptForm.reset();
            formHasChanges = false;
          },
          "Unsaved Changes",
          { confirmText: 'Yes', cancelText: 'No' }
        );
      } else {
        // Fallback to native confirm if Modal.js not available
        const confirmClose = confirm("You have unsaved changes. Are you sure you want to close?");
        if (!confirmClose) {
          return;
        }
        apptBackdrop.classList.add("hidden");
        apptForm.reset();
        formHasChanges = false;
      }
      return;
    }
    
    apptBackdrop.classList.add("hidden");
    apptForm.reset();
    formHasChanges = false;
  }

  // Validation helper functions
  function showApptError(fieldId, message) {
    const field = document.getElementById(fieldId);
    const error = document.getElementById(fieldId + "-error");
    
    if (!field || !error) return;
    
    field.classList.add('border-red-400');
    error.textContent = message;
    error.classList.remove('hidden');
  }

  function clearApptError(fieldId) {
    const field = document.getElementById(fieldId);
    const error = document.getElementById(fieldId + "-error");
    
    if (!field || !error) return;
    
    field.classList.remove('border-red-400');
    error.classList.add('hidden');
  }

  // Show pickup address suggestion
  function showPickupSuggestion(suggestion) {
    const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
    const suggestionText = document.getElementById('bookingPickupLocation-suggestion-text');
    
    if (!suggestionBtn || !suggestionText || !suggestion) return;
    
    suggestionText.textContent = suggestion;
    suggestionBtn.classList.remove('hidden');
  }

  // Hide pickup address suggestion
  function hidePickupSuggestion() {
    const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
    if (suggestionBtn) {
      suggestionBtn.classList.add('hidden');
    }
  }

  // New booking status helpers
  function showNewBookingStatus(message) {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    el.innerHTML = `<span class="mini-spinner"></span>${message}`;
    el.classList.remove('hidden');
  }

  function setNewBookingStatusText(message) {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    // Keep spinner if already present
    const hasSpinner = el.querySelector('.mini-spinner');
    el.innerHTML = `${hasSpinner ? '<span class="mini-spinner"></span>' : ''}${message}`;
    el.classList.remove('hidden');
  }

  function hideNewBookingStatus() {
    const el = document.getElementById('newBookingStatus');
    if (!el) return;
    el.classList.add('hidden');
    el.innerHTML = '';
  }

  // Apply pickup address suggestion
  function applyPickupSuggestion() {
    const suggestionText = document.getElementById('bookingPickupLocation-suggestion-text');
    const pickupInput = document.getElementById('bookingPickupLocation');
    
    if (!suggestionText || !pickupInput) return;
    
    const suggestion = suggestionText.textContent;
    if (suggestion) {
      pickupInput.value = suggestion;
      clearApptError('bookingPickupLocation');
      hidePickupSuggestion();
      formHasChanges = true;
    }
  }

  // Set up suggestion button click handler
  const suggestionBtn = document.getElementById('bookingPickupLocation-suggestion');
  if (suggestionBtn) {
    suggestionBtn.addEventListener('click', applyPickupSuggestion);
  }

  // Track changes to form inputs and clear errors on input
  apptForm.addEventListener("input", (e) => {
    formHasChanges = true;
    // Clear error for the field being edited
    if (e.target.id) {
      clearApptError(e.target.id);
      // Hide suggestion when user starts typing in pickup field
      if (e.target.id === 'bookingPickupLocation') {
        hidePickupSuggestion();
      }
    }
  });

  // Update end time based on service selection and start time
  function updateBookingEndTime() {
    const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;
    if (appointmentType !== 'booking') return;
    
    const serviceCode = document.getElementById('bookingService').value;
    const startTime = document.getElementById('appt-start').value;
    const date = document.getElementById('appt-date').value;
    
    if (!serviceCode || !startTime || !date) return;
    
    const duration = SERVICE_DURATIONS[serviceCode];
    if (!duration) {
      throw new Error(`No duration found for service: ${serviceCode}`);
    }
    
    const endTime = addMinutesToTime(startTime, date, duration);
    document.getElementById('appt-end').value = endTime;
  }

  // Toggle between personal appointment and booking
  const appointmentTypeRadios = document.querySelectorAll('input[name="appointmentType"]');
  appointmentTypeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const isBooking = radio.value === 'booking';
      const personalFields = document.getElementById('personal-title-field');
      const personalLocation = document.getElementById('personal-location-field');
      const bookingServiceField = document.getElementById('booking-service-field');
      const bookingFields = document.getElementById('bookingFields');
      const endTimeInput = document.getElementById('appt-end');
      const endTimeLabel = document.getElementById('appt-end-label');
      
      if (isBooking) {
        personalFields.style.display = 'none';
        personalLocation.style.display = 'none';
        bookingServiceField.style.display = 'block';
        bookingFields.style.display = 'block';
        endTimeInput.readOnly = true;
        endTimeLabel.innerHTML = 'End time';
        updateBookingEndTime();
      } else {
        personalFields.style.display = 'block';
        personalLocation.style.display = 'block';
        bookingServiceField.style.display = 'none';
        bookingFields.style.display = 'none';
        endTimeInput.readOnly = false;
        endTimeLabel.innerHTML = 'End time<span class="text-gray-400"> (optional)</span>';
      }
    });
  });

  // Toggle between existing client and new client
  const clientModeRadios = document.querySelectorAll('input[name="clientMode"]');
  clientModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const isNew = radio.value === 'new';
      const existingFields = document.getElementById('existingClientFields');
      const newFields = document.getElementById('newClientFields');
      
      if (isNew) {
        existingFields.style.display = 'none';
        newFields.style.display = 'block';
      } else {
        existingFields.style.display = 'block';
        newFields.style.display = 'none';
      }
    });
  });

  // Listen for service selection change to update end time
  document.getElementById('bookingService')?.addEventListener('change', () => {
    updateBookingEndTime();
  });

  // Listen for start time change to update end time
  document.getElementById('appt-start')?.addEventListener('change', () => {
    updateBookingEndTime();
  });

  // Listen for date change to update end time
  document.getElementById('appt-date')?.addEventListener('change', () => {
    updateBookingEndTime();
  });

  // Add real-time validation for pickup address
  const pickupInput = document.getElementById('bookingPickupLocation');
  if (pickupInput) {
    pickupInput.addEventListener('blur', function() {
      const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;
      if (appointmentType !== 'booking') return; // Only validate for bookings
      
      const value = this.value.trim();
      if (!value) return; // Don't show error on empty until submit
      
      const validation = validatePickupAddressForBooking(value);
      if (!validation.valid) {
        showApptError('bookingPickupLocation', validation.message);
      } else {
        clearApptError('bookingPickupLocation');
      }
    });
  }

  // Load clients from database
  async function loadClients() {
    const selectEl = document.getElementById('existingClientSelect');
    if (!selectEl) return;

    try {
      const { data: clients, error } = await window.supabaseClient
        .from('client')
        .select('id, first_name, last_name, email, mobile')
        .order('first_name');

      if (error) {
        console.error('[admin-calendar] Error loading clients:', error);
        selectEl.innerHTML = '<option value="">Error loading clients</option>';
        return;
      }

      if (!clients || clients.length === 0) {
        selectEl.innerHTML = '<option value="">No clients found</option>';
        return;
      }

      // Populate select with clients
      selectEl.innerHTML = '<option value="">Select a client...</option>' +
        clients.map(c => {
          const fullName = [c.first_name, c.last_name].filter(Boolean).join(' ');
          return `<option value="${c.id}" data-first-name="${c.first_name || ''}" data-last-name="${c.last_name || ''}" data-email="${c.email || ''}" data-mobile="${c.mobile || ''}">${fullName} (${c.email || 'no email'})</option>`;
        }).join('');

      console.log(`[admin-calendar] Loaded ${clients.length} clients`);
    } catch (err) {
      console.error('[admin-calendar] Exception loading clients:', err);
      selectEl.innerHTML = '<option value="">Error loading clients</option>';
    }
  }

  // Helper function to get bookable services from config
  function getBookingServicesFromConfig() {
    if (!window.SITE_CONFIG || !Array.isArray(window.SITE_CONFIG.BOOKING_CATEGORIES)) {
      console.warn('[admin-calendar] SITE_CONFIG.BOOKING_CATEGORIES not available');
      return [];
    }

    return window.SITE_CONFIG.BOOKING_CATEGORIES
      .filter(cat => !cat.comingSoon)          // skip manual "coming soon"
      .flatMap(cat => (cat.services || []).map(svc => {
        // Require durationMinutes as a number - no parsing, no fallbacks
        if (typeof svc.durationMinutes !== 'number') {
          throw new Error(`Missing durationMinutes for service: ${svc.id}`);
        }

        // Populate SERVICE_DURATIONS map with service id as key
        SERVICE_DURATIONS[svc.id] = svc.durationMinutes;

        return {
          id: svc.id,              // used as <option> value
          name: svc.name,
          duration: svc.duration,  // e.g. "1 hour"
          durationMinutes: svc.durationMinutes,
          price: svc.price,
          categoryId: cat.id,
          categoryName: cat.name
        };
      }));
  }

  // Populate service dropdown from config
  function loadServices() {
    const serviceSelect = document.getElementById('bookingService');
    if (!serviceSelect) return;

    // Clear existing options except the first (placeholder)
    serviceSelect.innerHTML = '<option value="">Select a service...</option>';

    const services = getBookingServicesFromConfig();
    
    if (services.length === 0) {
      console.warn('[admin-calendar] No services found in BOOKING_CATEGORIES');
      return;
    }

    services.forEach(svc => {
      const opt = document.createElement('option');
      opt.value = svc.id;                       // must match SERVICE_DURATIONS key
      // Label e.g. "Automatic Driving Lesson 1 hour" or "Senior Automatic Driving Lesson 1 hour"
      opt.textContent = `${svc.name} ${svc.duration}`;
      serviceSelect.appendChild(opt);
    });

    console.log(`[admin-calendar] Loaded ${services.length} services from config`);
    console.log('[admin-calendar] Service durations:', SERVICE_DURATIONS);
  }

  // Load clients and services when modal opens
  const originalOpenModal = openAppointmentModal;
  openAppointmentModal = function(defaults = {}) {
    originalOpenModal(defaults);
    loadClients();
    loadServices();
  };

  btnNewAppointment.addEventListener("click", () => {
    openAppointmentModal();
  });

  apptCloseBtn.addEventListener("click", () => closeAppointmentModal());
  apptCancelBtn.addEventListener("click", () => closeAppointmentModal());

  // Close when clicking outside the modal
  apptBackdrop.addEventListener("click", (e) => {
    if (e.target === apptBackdrop) {
      closeAppointmentModal();
    }
  });

  // Helper function to validate address format (matches validate-bookings Edge Function)
  function isValidAddress(addr) {
    if (!addr || addr.trim().length < 5) return false;
    
    const trimmed = addr.trim();
    
    // Must have at least 2 consecutive letters
    if (!/[a-zA-Z]{2,}/.test(trimmed)) return false;
    
    // Check for obvious test data
    const testPatterns = [
      /^test$/i,
      /^asdf/i,
      /^qwerty/i,
      /^xxx/i,
      /^temp$/i,
      /^sample$/i,
      /^n\/?a$/i,
      /^tbd$/i,
      /^none$/i,
      /^dsffdsa$/i  // Matches the user's screenshot
    ];
    
    if (testPatterns.some(pattern => pattern.test(trimmed))) {
      return false;
    }
    
    return true;
  }

  // Enhanced pickup validation with helpful error messages
  function validatePickupAddressForBooking(addr) {
    if (!addr || addr.trim() === '') {
      return { valid: false, message: 'Pickup address is required' };
    }
    
    const trimmed = addr.trim();
    
    if (trimmed.length < 5) {
      return { valid: false, message: 'Address is too short (minimum 5 characters)' };
    }
    
    if (!/[a-zA-Z]{2,}/.test(trimmed)) {
      return { valid: false, message: 'Address must contain at least 2 consecutive letters' };
    }
    
    // Check for test data
    const testPatterns = [
      { pattern: /^test$/i, name: 'test' },
      { pattern: /^asdf/i, name: 'test keyboard input' },
      { pattern: /^qwerty/i, name: 'test keyboard input' },
      { pattern: /^xxx/i, name: 'placeholder' },
      { pattern: /^temp$/i, name: 'temporary' },
      { pattern: /^sample$/i, name: 'sample' },
      { pattern: /^n\/?a$/i, name: 'N/A' },
      { pattern: /^tbd$/i, name: 'TBD' },
      { pattern: /^none$/i, name: 'none' },
      { pattern: /^dsffdsa$/i, name: 'test' },
      { pattern: /^pickup\s*(location|address)?$/i, name: 'placeholder' },
      { pattern: /^address$/i, name: 'placeholder' },
      { pattern: /^location$/i, name: 'placeholder' }
    ];
    
    for (const { pattern, name } of testPatterns) {
      if (pattern.test(trimmed)) {
        return { valid: false, message: `This looks like ${name} data. Please enter a real pickup address.` };
      }
    }
    
    return { valid: true, message: null };
  }

  // Validate address with Google Maps via Edge Function (like Admin Bookings)
  async function validateAddressWithBackend(address) {
    try {
      // Call the validate-bookings Edge Function with address-only mode
      const { data, error } = await window.supabaseClient.functions.invoke('validate-bookings', {
        body: { 
          validate_address_only: true,
          address: address 
        }
      });
      
      if (error) {
        console.error('[admin-calendar] Address validation error:', error);
        return { 
          valid: false, 
          message: 'Could not validate address. Please check your internet connection.',
          issue: 'network_error'
        };
      }
      
      if (data && data.validation_result) {
        const result = data.validation_result;
        
        if (result.isValid) {
          return { valid: true, message: null };
        } else {
          // Map issue codes to user-friendly messages (matching Admin Bookings)
          const issueMessages = {
            'partial_match': 'We found a similar address but it is not an exact match. Please check the street number and suburb.',
            'street_mismatch': 'We could not match this street or suffix (road, drive, etc). Please check the spelling.',
            'suburb_mismatch': 'We matched the street, but the suburb looks different. Please check the suburb.',
            'street_number_mismatch': 'The street number doesn\'t match. Please check the number.',
            'not_found': 'We could not find this address in Google Maps. Please check the number, street and suburb.',
            'google_no_result': 'Address not found on Google Maps. Please enter a valid address.',
            'too_short': 'Address is too short. Please enter a complete address.',
            'not_enough_letters': 'Address must contain more letters.',
            'test_data': 'This looks like test data. Please enter a real address.',
            'empty': 'Address is required.',
            'unknown': 'Please provide a valid address.'
          };
          
          const message = issueMessages[result.issue] || 'Please provide a valid address.';
          
          return {
            valid: false,
            message: message,
            issue: result.issue,
            suggestion: result.suggestion
          };
        }
      }
      
      // If no result from backend, treat as validation failure (fail secure)
      console.error('[admin-calendar] No validation_result in response, treating as invalid');
      return { 
        valid: false, 
        message: 'Could not validate address with Google Maps. Please check the address and try again.',
        issue: 'no_result'
      };
      
    } catch (err) {
      console.error('[admin-calendar] Address validation exception:', err);
      return { 
        valid: false, 
        message: 'Could not validate address. Please try again.',
        issue: 'exception'
      };
    }
  }

  // Helper function to convert 24-hour time to 12-hour format with AM/PM
  function convert24To12Hour(time24) {
    const [hours, minutes] = time24.split(':').map(Number);
    const period = hours >= 12 ? 'PM' : 'AM';
    const hours12 = hours % 12 || 12;
    return `${String(hours12).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
  }

  // Handle form submission
  apptForm.addEventListener("submit", async (event) => {
    event.preventDefault();

    // Check appointment type
    const appointmentType = document.querySelector('input[name="appointmentType"]:checked')?.value;

    if (appointmentType === 'booking') {
      await handleBookingSubmit();
    } else {
      await handlePersonalAppointmentSubmit();
    }
  });

  // Handle personal appointment submission
  async function handlePersonalAppointmentSubmit() {
    const title = document.getElementById("appt-title").value.trim();
    const date = document.getElementById("appt-date").value;
    const startTime = document.getElementById("appt-start").value;
    const endTime = document.getElementById("appt-end").value;
    const location = document.getElementById("appt-location").value.trim();

    // Clear all errors first
    clearApptError("appt-title");
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("appt-location");

    // Validate required fields
    let hasError = false;
    if (!title) {
      showApptError("appt-title", "Title is required");
      hasError = true;
    }
    if (!date) {
      showApptError("appt-date", "Date is required");
      hasError = true;
    }
    if (!startTime) {
      showApptError("appt-start", "Start time is required");
      hasError = true;
    }
    // Location is optional, but if provided, must be valid
    if (location && !isValidAddress(location)) {
      showApptError("appt-location", "Please provide a valid address (minimum 5 characters)");
      hasError = true;
    }

    if (hasError) {
      return;
    }

    try {
      console.log("[appointment] Creating personal appointment via edge function");

      // Convert 24-hour time to 12-hour format for the edge function
      const startTime12 = convert24To12Hour(startTime);
      const endTime12 = endTime ? convert24To12Hour(endTime) : null;

      // Call edge function to create Google Calendar event and insert into DB
      const { data, error } = await window.supabaseClient.functions.invoke('create-admin-appointment', {
        body: { 
          title,
          date,
          startTime: startTime12,
          endTime: endTime12,
          location
        }
      });

      if (error) {
        console.error("[appointment] Edge function error:", error);
        throw new Error(error.message || "Failed to create appointment");
      }

      if (!data || !data.ok) {
        console.error("[appointment] Edge function returned error:", data);
        throw new Error(data?.error || "Failed to create appointment");
      }

      console.log("[appointment] ✅ Appointment created successfully:", data);
      const googleEventId = data?.googleEvent?.id;

      closeAppointmentModal(true); // Force close without confirmation since we just saved

      // Show success message
      if (window.Modal && window.Modal.success) {
        window.Modal.success("Appointment created successfully!", "Success");
      }

      // Poll database directly for the new event by Google event ID
      // This is more efficient than refreshing the UI multiple times
      console.log("[appointment] Waiting for gcal-sync to process the new event...", googleEventId);
      
      let pollAttempts = 0;
      const maxPolls = 10; // Try for up to 30 seconds (10 attempts x 3 seconds)
      
      const pollForEvent = async () => {
        pollAttempts++;
        setNewBookingStatusText(`Waiting for new booking...  (${pollAttempts}/${maxPolls})`);
        console.log(`[appointment] Checking database for new event (attempt ${pollAttempts}/${maxPolls})...`);
        
        try {
          // Query database directly for the Google event ID
          const { data: booking, error } = await window.supabaseClient
            .from('booking')
            .select('id, google_event_id')
            .eq('google_event_id', googleEventId)
            .maybeSingle();
          
          if (booking) {
            // Event found in database!
            console.log(`[appointment] ✅ Event found in database! Refreshing calendar once.`, booking);
            hideNewBookingStatus();
            renderWeek(weekStart);
            return; // Stop polling
          }
          
          if (error && error.code !== 'PGRST116') {
            // PGRST116 is "no rows returned" which is expected, other errors are real issues
            console.error('[appointment] Database query error:', error);
          }
          
          // Not found yet, continue polling if we haven't hit max attempts
          if (pollAttempts < maxPolls) {
            console.log(`[appointment] Event not yet in database, retrying in 3 seconds...`);
            setTimeout(pollForEvent, 3000);
          } else {
            console.warn(`[appointment] ⚠️ Event not found after ${maxPolls} attempts. Webhook may be delayed.`);
            hideNewBookingStatus();
            // Do one final refresh anyway
            renderWeek(weekStart);
          }
        } catch (err) {
          console.error('[appointment] Error polling for event:', err);
          if (pollAttempts < maxPolls) {
            setTimeout(pollForEvent, 3000);
          } else {
            hideNewBookingStatus();
          }
        }
      };
      
      // Start polling after 2 seconds (give webhook a head start)
      showNewBookingStatus('Waiting for new booking...');
      setTimeout(pollForEvent, 2000);
    } catch (err) {
      console.error("[appointment] Failed to create appointment", err);
      
      // Show user-friendly error message
      if (window.Modal && window.Modal.error) {
        window.Modal.error(
          err.message || "Could not save appointment. Please try again.",
          "Error"
        );
      } else {
        alert("Could not save appointment. Please try again. Error: " + (err.message || err));
      }
    }
  }

  // Handle booking submission
  async function handleBookingSubmit() {
    const date = document.getElementById("appt-date").value;
    const startTime = document.getElementById("appt-start").value;
    const endTime = document.getElementById("appt-end").value;
    
    const serviceSelect = document.getElementById("bookingService");
    const serviceCode = serviceSelect.value;
    const serviceLabel = serviceSelect.options[serviceSelect.selectedIndex]?.text || "";

    const clientMode = document.querySelector('input[name="clientMode"]:checked')?.value;
    
    const existingClientSelect = document.getElementById("existingClientSelect");
    const clientId = clientMode === "existing" ? existingClientSelect.value : null;
    
    const firstName = clientMode === "new" 
      ? document.getElementById("newClientFirstName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.firstName || "";
    const lastName = clientMode === "new"
      ? document.getElementById("newClientLastName").value.trim()
      : existingClientSelect.selectedOptions[0]?.dataset.lastName || "";
    const email = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.email || ""
      : document.getElementById("newClientEmail").value.trim();
    const mobile = clientMode === "existing"
      ? existingClientSelect.selectedOptions[0]?.dataset.mobile || ""
      : document.getElementById("newClientMobile").value.trim();
    
    const pickupLocation = document.getElementById("bookingPickupLocation").value.trim();
    const isPaymentRequired = document.getElementById("bookingPaymentRequired").checked;

    // Clear all errors first
    clearApptError("appt-date");
    clearApptError("appt-start");
    clearApptError("bookingService");
    clearApptError("existingClientSelect");
    clearApptError("newClientFirstName");
    clearApptError("newClientLastName");
    clearApptError("newClientEmail");
    clearApptError("newClientMobile");
    clearApptError("bookingPickupLocation");

    // Validate required fields
    let hasError = false;
    
    if (!date) {
      showApptError("appt-date", "Date is required");
      hasError = true;
    }
    if (!startTime) {
      showApptError("appt-start", "Start time is required");
      hasError = true;
    }
    if (!serviceCode) {
      showApptError("bookingService", "Please select a service");
      hasError = true;
    }
    
    if (clientMode === "existing") {
      if (!clientId) {
        showApptError("existingClientSelect", "Please select a client");
        hasError = true;
      }
    } else {
      if (!firstName) {
        showApptError("newClientFirstName", "First name is required");
        hasError = true;
      }
      if (!lastName) {
        showApptError("newClientLastName", "Last name is required");
        hasError = true;
      }
      if (!email || !email.includes('@')) {
        showApptError("newClientEmail", "Valid email is required");
        hasError = true;
      }
      if (!mobile) {
        showApptError("newClientMobile", "Mobile is required");
        hasError = true;
      }
    }
    
    // Enhanced pickup address validation
    const pickupValidation = validatePickupAddressForBooking(pickupLocation);
    if (!pickupValidation.valid) {
      showApptError("bookingPickupLocation", pickupValidation.message);
      hasError = true;
    }

    if (hasError) {
      return;
    }

    // Show loading state on button only
    const saveBtn = document.getElementById('appointment-save');
    const originalBtnText = saveBtn ? saveBtn.textContent : '';
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }

    try {
      // Validate address with Google Maps before saving
      console.log("[booking] Validating pickup address with Google Maps...");
      const backendValidation = await validateAddressWithBackend(pickupLocation);
      
      if (!backendValidation.valid) {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = originalBtnText;
        }
        
        // Show validation error
        showApptError("bookingPickupLocation", backendValidation.message);
        
        // Show suggestion button if available
        if (backendValidation.suggestion) {
          showPickupSuggestion(backendValidation.suggestion);
        } else {
          hidePickupSuggestion();
        }
        
        console.log("[booking] Address validation failed:", backendValidation.issue);
        return; // STOP HERE - do not save
      }
      
      console.log("[booking] Address validated successfully");
      console.log("[booking] Creating admin booking via edge function");

      // Convert 24-hour time to 12-hour format for the edge function
      const startTime12 = convert24To12Hour(startTime);
      const endTime12 = endTime ? convert24To12Hour(endTime) : null;

      const payload = {
        appointmentType: "booking",
        serviceCode,
        serviceLabel,
        date,
        startTime: startTime12,
        endTime: endTime12,
        clientId: clientId || null,
        firstName,
        lastName: lastName || null,
        email,
        mobile,
        pickupLocation,
        isPaymentRequired,
      };

      console.log("[booking] Payload:", payload);

      // Call edge function to create Google Calendar event
      const { data, error } = await window.supabaseClient.functions.invoke('create-admin-booking', {
        body: payload
      });

      if (error) {
        console.error("[booking] Edge function error:", error);
        throw new Error(error.message || "Failed to create booking");
      }

      if (!data || !data.ok) {
        console.error("[booking] Edge function returned error:", data);
        throw new Error(data?.error || "Failed to create booking");
      }

      console.log("[booking] ✅ Booking created successfully:", data);
      const googleEventId = data?.googleEvent?.id;

      closeAppointmentModal(true); // Force close without confirmation since we just saved

      // Show success message
      if (window.Modal && window.Modal.success) {
        window.Modal.success("Booking created successfully!", "Success");
      }

      // Poll database directly for the new event by Google event ID
      console.log("[booking] Waiting for gcal-sync to process the new event...", googleEventId);
      
      let pollAttempts = 0;
      const maxPolls = 10;
      
      const pollForEvent = async () => {
        pollAttempts++;
        setNewBookingStatusText(`Waiting for new booking...  (${pollAttempts}/${maxPolls})`);
        console.log(`[booking] Checking database for new event (attempt ${pollAttempts}/${maxPolls})...`);
        
        try {
          const { data: booking, error } = await window.supabaseClient
            .from('booking')
            .select('id, google_event_id')
            .eq('google_event_id', googleEventId)
            .maybeSingle();
          
          if (booking) {
            console.log(`[booking] ✅ Event found in database! Refreshing calendar.`, booking);
            hideNewBookingStatus();
            renderWeek(weekStart);
            return;
          }
          
          if (error && error.code !== 'PGRST116') {
            console.error('[booking] Database query error:', error);
          }
          
          if (pollAttempts < maxPolls) {
            console.log(`[booking] Event not yet in database, retrying in 3 seconds...`);
            setTimeout(pollForEvent, 3000);
          } else {
            console.warn(`[booking] ⚠️ Event not found after ${maxPolls} attempts.`);
            hideNewBookingStatus();
            renderWeek(weekStart);
          }
        } catch (err) {
          console.error('[booking] Error polling for event:', err);
          if (pollAttempts < maxPolls) {
            setTimeout(pollForEvent, 3000);
          } else {
            hideNewBookingStatus();
          }
        }
      };
      
      // Start polling after 2 seconds
      showNewBookingStatus('Waiting for new booking...');
      setTimeout(pollForEvent, 2000);
    } catch (err) {
      console.error("[booking] Error creating booking:", err);
      if (window.Modal && window.Modal.alert) {
        window.Modal.alert("Failed to create booking. Please try again.");
      } else {
        alert("Failed to create booking. Please try again.");
      }
    } finally {
      // Re-enable save button
      const saveBtn = document.getElementById('appointment-save');
      if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText || 'Save';
      }
    }
  }

  function renderWeek(startDate) {
    weekStart = new Date(startDate);
    weekStart.setDate(weekStart.getDate() - weekStart.getDay());
    // Set to start of day (midnight) to avoid timezone issues
    weekStart.setHours(0, 0, 0, 0);
    const grid = document.getElementById('weekGrid');
    if (!grid) return;
    grid.innerHTML = '';

    // Display week range
    const weekEnd = addDays(weekStart, 6);
    const rangeEl = document.getElementById('weekRange');
    if (rangeEl) {
      const formatShortDate = (date) => {
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = String(date.getFullYear()).slice(-2);
        return `${day}/${month}/${year}`;
      };
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      rangeEl.textContent = isMobile
        ? `${formatShortDate(weekStart)} - ${formatShortDate(weekEnd)}`
        : `Week: ${formatShortDate(weekStart)} - ${formatShortDate(weekEnd)}`;
    }

    // Header row with dates
    const headerRow = document.createElement('div');
    headerRow.className = 'contents';
    const days = ['Time', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    days.forEach((day, idx) => {
      const cell = document.createElement('div');
      cell.className = 'calendar-header font-semibold p-2 border sticky top-0 z-10';
      if (idx === 0) cell.classList.add('left-0', 'z-20');
      if (idx > 0) {
        const date = addDays(weekStart, idx - 1);
        // For mobile: show day name on line 1, date on line 2
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        if (isMobile) {
          cell.innerHTML = `<div style="line-height: 1.1;">${day}</div><div style="line-height: 1.1;">${date.getDate()}/${date.getMonth() + 1}</div>`;
        } else {
          cell.textContent = `${day} ${date.getDate()}/${date.getMonth() + 1}`;
        }
      } else {
        cell.textContent = day;
      }
      headerRow.appendChild(cell);
    });
    grid.appendChild(headerRow);

    // Time slots (8am-6pm)
    const dayCells = {};
    for (let h = 8; h < 18; h++) {
      const row = document.createElement('div');
      row.className = 'contents';
      const timeCell = document.createElement('div');
      timeCell.className = 'calendar-time-cell p-2 border sticky left-0 z-10 font-medium';
      timeCell.textContent = `${h}:00`;
      row.appendChild(timeCell);
      for (let d = 0; d < 7; d++) {
        const cell = document.createElement('div');
        cell.className = 'p-2 border min-h-[80px] relative overflow-visible cursor-pointer hover:bg-blue-50 transition-colors';
        cell.dataset.day = d;
        cell.dataset.hour = h;
        const key = `${d}-${h}`;
        dayCells[key] = cell;
        
        // Add click handler to open appointment modal with pre-filled date/time
        cell.addEventListener('click', (e) => {
          // Don't trigger if clicking on a booking card
          if (e.target.closest('.booking-card')) return;
          
          const dayIndex = parseInt(cell.dataset.day); // 0=Sunday, 1=Monday, ..., 6=Saturday
          const hour = parseInt(cell.dataset.hour);
          
          // Calculate the actual date for this cell (no offset, dayIndex is already 0-based for Sunday)
          const selectedDate = new Date(weekStart);
          selectedDate.setDate(weekStart.getDate() + dayIndex);
          
          // Format date as YYYY-MM-DD for HTML date input
          const yyyy = selectedDate.getFullYear();
          const mm = String(selectedDate.getMonth() + 1).padStart(2, '0');
          const dd = String(selectedDate.getDate()).padStart(2, '0');
          const dateStr = `${yyyy}-${mm}-${dd}`;
          
          // Format time as HH:MM for time input
          const timeStr = `${String(hour).padStart(2, '0')}:00`;
          
          // Open modal with pre-filled date and time
          openAppointmentModal({
            date: dateStr,
            startTime: timeStr
          });
        });
        
        row.appendChild(cell);
      }
      grid.appendChild(row);
    }

    // Fetch and display bookings
    fetchBookings(weekStart, dayCells);

    // Update Today button with current day number
    const todayBtn = document.getElementById('todayBtn');
    const todayNum = new Date().getDate();
    const todayText = todayBtn.querySelector('text');
    if (todayText) {
      todayText.textContent = todayNum;
    }

    // Controls
    todayBtn.onclick = () => renderWeek(new Date());
    document.getElementById('prevWeek').onclick = () => { const d = addDays(weekStart,-7); renderWeek(d); };
    document.getElementById('nextWeek').onclick = () => { const d = addDays(weekStart,7); renderWeek(d); };
    document.getElementById('refreshBtn').onclick = () => renderWeek(weekStart); // Refresh current week
  }

  async function fetchBookings(weekStart, dayCells) {
    if (!window.supabaseClient) {
      console.error('❌ Supabase client not initialized');
      const calendar = document.getElementById('calendar');
      if (calendar) {
        calendar.innerHTML = '<div class="p-4 bg-red-50 text-red-800 rounded">❌ Supabase client not initialized. Check console for errors.</div>';
      }
      return;
    }

    const weekEnd = addDays(weekStart, 7);
    console.log('📅 Fetching bookings for week:', weekStart.toISOString(), 'to', weekEnd.toISOString());
    
    // First, fetch all services to create a lookup map
    const { data: services, error: servicesError } = await window.supabaseClient
      .from('service')
      .select('code, name, price_cents');
    
    const serviceMap = {};
    const servicePriceMap = {};
    if (services && !servicesError) {
      services.forEach(svc => {
        serviceMap[svc.code] = svc.name;
        servicePriceMap[svc.code] = svc.price_cents;
      });
    }
    
    // Helper: Get short service label
    const getServiceShortLabel = (serviceCode) => {
      switch (serviceCode) {
        case 'auto_60': return 'Auto - 1h';
        case 'auto_90': return 'Auto - 1.5h';
        case 'auto_120': return 'Auto - 2h';
        case 'manual_60': return 'Manual - 1h';
        case 'manual_90': return 'Manual - 1.5h';
        case 'manual_120': return 'Manual - 2h';
        case 'senior_auto_60': return 'Senior auto - 1h';
        case 'senior_manual_60': return 'Senior manual - 1h';
        default: return 'Lesson';
      }
    };
    
    // Helper: Generate red $ marker if payment required
    const getPaymentMarker = (booking) => {
      return booking.is_payment_required ? '<span class="payment-marker">$</span>' : '';
    };
    
    // Query bookings - exclude cancelled bookings
    const { data: bookings, error } = await window.supabaseClient
      .from('booking')
      .select('*')
      .gte('start_time', weekStart.toISOString())
      .lt('start_time', weekEnd.toISOString())
      .neq('status', 'cancelled')
      .order('start_time');

    if (error) {
      console.error('❌ Error fetching bookings:', error);
      const weekRange = document.getElementById('weekRange');
      if (weekRange) {
        weekRange.innerHTML = `<span class="text-red-600">⚠️ Error loading bookings: ${error.message}</span>`;
      }
      return;
    }
    
    console.log(`✅ Found ${bookings?.length || 0} bookings for this week:`, bookings);

    if (!bookings || bookings.length === 0) {
      console.log('ℹ️ No bookings found for this week');

      // Update week range
      const weekRange = document.getElementById('weekRange');
      if (weekRange) {
        const formatShortDate = (date) => {
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = String(date.getFullYear()).slice(-2);
          return `${day}/${month}/${year}`;
        };
        weekRange.textContent = `Week: ${formatShortDate(weekStart)} - ${formatShortDate(addDays(weekStart, 6))}`;
      }

      // Show message beside buttons
      const msg = document.getElementById('noBookingsMsg');
      if (msg) {
        msg.textContent = "No bookings found for this week";
        msg.classList.remove("hidden");
      }

      return;
    } else {
      const msg = document.getElementById('noBookingsMsg');
      if (msg) msg.classList.add("hidden");
    }

    bookings.forEach(booking => {
      const start = new Date(booking.start_time);
      const end = new Date(booking.end_time);
      
      // Database stores TIMESTAMPTZ which JavaScript converts to local browser time
      // Use local time methods since the Date object is already in browser timezone
      const dayOfWeek = start.getDay();
      const hour = start.getHours();
      const key = `${dayOfWeek}-${hour}`;
      const cell = dayCells[key];
      
      // Calculate duration in hours for spanning multiple time slots
      const durationMs = end.getTime() - start.getTime();
      const durationHours = durationMs / (1000 * 60 * 60);
      
      console.log('📍 Placing booking:', { 
        booking_id: booking.id, 
        dayOfWeek, 
        hour, 
        key, 
        hasCell: !!cell, 
        is_booking: booking.is_booking,
        durationHours: durationHours.toFixed(2)
      });
      
      if (cell) {
        const bookingDiv = document.createElement('div');
        // JavaScript Date automatically converts to browser local time
        const time = start.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
        const endTime = end.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
        
        // Calculate exact pixel height based on duration
        // Each cell is 80px min-height on desktop, 48px on mobile
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        // Determine actual rendered cell height (fallback to defaults)
        let cellHeight = isMobile ? 48 : 80;
        try {
          // Find any existing time slot cell to measure
          const sampleCell = document.querySelector('#weekGrid div.p-2.border.min-h-[80px]');
          if (sampleCell) {
            cellHeight = sampleCell.getBoundingClientRect().height || cellHeight;
          }
        } catch (e) { /* ignore measurement errors */ }
        // Desktop-only: subtract vertical padding to use the content height so 1h equals exactly one grid rectangle
        let effectiveCellHeight = cellHeight;
        if (!isMobile) {
          const cs = getComputedStyle(cell);
          const py = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
          effectiveCellHeight = Math.max(cellHeight - py, 0);
        }
        const heightPx = durationHours * effectiveCellHeight;
        
        // Decide detail level by visual height (works for 1h/1.5h/2h)
        let detailLevel = 1;                    // ~1h
        if (heightPx >= 120) detailLevel = 2;   // ~1.5h
        if (heightPx >= 160) detailLevel = 3;   // ~2h
        
        // Calculate minutes offset from the hour for precise positioning
        const minutes = start.getMinutes();
        const minuteOffset = (minutes / 60) * effectiveCellHeight;
        
        // Use is_booking flag to determine display type
        if (booking.is_booking) {
          // This is a booking with client information - show service name
          bookingDiv.className = 'booking-card text-xs border-l-2 border-blue-600 p-1 rounded absolute left-0 right-0 z-10';
          bookingDiv.style.backgroundColor = '#bfdbfe';
          bookingDiv.style.color = '#111827';
          const padAdjust = isMobile ? 4 : 8; // subtract internal card padding so the block visually fits one rectangle
          bookingDiv.style.height = `${Math.max(heightPx - padAdjust, 4)}px`;
          bookingDiv.style.top = `${minuteOffset}px`;
          
          const serviceName = serviceMap[booking.service_code] || 'Driving Lesson';
          const clientName = [booking.first_name, booking.last_name].filter(Boolean).join(' ') || 'Unknown Client';
          
          // Get short service label
          const titleText = getServiceShortLabel(booking.service_code);
          
          // Build a compact location label for mobile
          let locationLabel = '';
          if (booking.pickup_location) {
            // Trim whitespace and remove trailing commas
            locationLabel = booking.pickup_location.trim().replace(/,+$/, '');
            // Truncate for small screens
            if (locationLabel.length > 26) {
              locationLabel = locationLabel.substring(0, 26) + '...';
            }
          }
          
          // Build HTML based on detail level
          let summaryHTML = '';
          let detailsHTML = '';
          
          if (detailLevel === 1) {
            // Compact view: desktop shows richer info; mobile minimal (transmission + duration + address)
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine = `${titleText}${paymentMarker}`;
            const shortTransmission = titleText.split(' - ')[0]; // Extract 'Auto' or 'Manual' for mobile
            // Duration implied by block height; omit address in desktop summary to reduce duplication.
            const desktopAddress = booking.pickup_location ? `📍 ${booking.pickup_location}` : '';
            summaryHTML = `
              <div class="desktop-only font-semibold" style="color:#111827;">${transmissionLine}</div>
              <!-- Desktop summary shows address only; client name removed for space -->
              <div class="desktop-only summary-address-l1" style="color:#374151;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;line-height:1.2;">${desktopAddress}</div>
              <div class="mobile-only font-semibold" style="color:#111827;">${shortTransmission}</div>
              <div class="mobile-only" style="display:none;color:#374151;">${locationLabel}</div>
            `;
            // Details order (both desktop + mobile): Auto/Manual, Address, Client, Mobile, Time, Status
            const addressInDetailsL1 = booking.pickup_location ? `<div class="text-xs mb-1 details-address-l1" style="color:#1e40af;">📍 ${booking.pickup_location}</div>` : '';
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#1e40af;">${transmissionLine}</div>
              ${addressInDetailsL1}
              <div class="text-sm font-semibold mb-1" style="color:#1e40af;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#1e40af;">📱 ${booking.mobile}</div>` : ''}
              <div class="text-xs mb-1 font-medium" style="color:#1e40af;">🕐 ${time} - ${endTime}</div>
              ${typeof booking.price_cents === 'number' ? `<label class="payment-toggle ${booking.is_payment_required ? 'unpaid' : ''}">
                <input type="checkbox" class="payment-toggle-checkbox" ${!booking.is_payment_required ? 'checked' : ''} data-booking-id="${booking.id}" />
                <span class="payment-label">
                  $${(booking.price_cents / 100).toFixed(0)} paid
                </span>
              </label>` : ''}
              <div class="mt-1">
                <select class="booking-status-select text-xs border border-gray-300 rounded px-1 py-0.5 w-full" 
                        data-booking-id="${booking.id}" 
                        data-google-event-id="${booking.google_event_id || ''}"
                        data-original-status="${booking.status || 'confirmed'}">
                  <option value="confirmed" ${(booking.status || 'confirmed') === 'confirmed' ? 'selected' : ''}>Confirmed</option>
                  <option value="completed" ${booking.status === 'completed' ? 'selected' : ''}>Completed</option>
                  <option value="cancelled" ${booking.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                  <option value="no_show" ${booking.status === 'no_show' ? 'selected' : ''}>No Show</option>
                </select>
              </div>
            `;
          } else if (detailLevel === 2) {
            // 1.5 hours: Show service, client, address (2 lines), times, mobile. Status on hover.
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine2 = `${titleText}${paymentMarker}`;
            summaryHTML = `
              <div class="font-semibold" style="color:#111827;">${transmissionLine2}</div>
              <!-- Client name removed from web summary to prioritise address -->
              ${booking.pickup_location ? `<div class="text-xs summary-address" style="color:#374151;display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.3;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-xs mt-1 font-medium" style="color:#374151;">🕐 ${time} - ${endTime}</div>
              ${booking.mobile ? `<div class="text-xs summary-mobile" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
            `;
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${transmissionLine2}</div>
              ${booking.pickup_location ? `<div class="text-xs mb-1" style="color:#374151;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              ${typeof booking.price_cents === 'number' ? `<label class="payment-toggle ${booking.is_payment_required ? 'unpaid' : ''}">
                <input type="checkbox" class="payment-toggle-checkbox" ${!booking.is_payment_required ? 'checked' : ''} data-booking-id="${booking.id}" />
                <span class="payment-label">
                  $${(booking.price_cents / 100).toFixed(0)} paid
                </span>
              </label>` : ''}
              <div class="mt-1">
                <select class="booking-status-select text-xs border border-gray-300 rounded px-1 py-0.5 w-full" 
                        data-booking-id="${booking.id}" 
                        data-google-event-id="${booking.google_event_id || ''}"
                        data-original-status="${booking.status || 'confirmed'}">
                  <option value="confirmed" ${(booking.status || 'confirmed') === 'confirmed' ? 'selected' : ''}>Confirmed</option>
                  <option value="completed" ${booking.status === 'completed' ? 'selected' : ''}>Completed</option>
                  <option value="cancelled" ${booking.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                  <option value="no_show" ${booking.status === 'no_show' ? 'selected' : ''}>No Show</option>
                </select>
              </div>
            `;
          } else {
            // 2+ hours: Show all info including status
            const paymentMarker = getPaymentMarker(booking);
            const transmissionLine3 = `${titleText}${paymentMarker}`;
            summaryHTML = `
              <div class="font-semibold" style="color:#111827;">${transmissionLine3}</div>
              <!-- Client name removed from web summary to prioritise address -->
              ${booking.pickup_location ? `<div class="text-xs summary-address" style="color:#374151;display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.3;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-xs mt-1 font-medium" style="color:#374151;">🕐 ${time} - ${endTime}</div>
              ${booking.mobile ? `<div class="text-xs summary-mobile" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              <div class="mt-1 desktop-only">
                <select class="booking-status-select text-xs border border-gray-300 rounded px-1 py-0.5 w-full" 
                        data-booking-id="${booking.id}" 
                        data-google-event-id="${booking.google_event_id || ''}"
                        data-original-status="${booking.status || 'confirmed'}">
                  <option value="confirmed" ${(booking.status || 'confirmed') === 'confirmed' ? 'selected' : ''}>Confirmed</option>
                  <option value="completed" ${booking.status === 'completed' ? 'selected' : ''}>Completed</option>
                  <option value="cancelled" ${booking.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                  <option value="no_show" ${booking.status === 'no_show' ? 'selected' : ''}>No Show</option>
                </select>
              </div>
            `;
            detailsHTML = `
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${transmissionLine3}</div>
              ${booking.pickup_location ? `<div class="text-xs mb-1" style="color:#374151;">📍 ${booking.pickup_location}</div>` : ''}
              <div class="text-sm font-semibold mb-1" style="color:#111827;">${clientName}</div>
              ${booking.mobile ? `<div class="text-xs mb-1" style="color:#374151;">📱 ${booking.mobile}</div>` : ''}
              ${typeof booking.price_cents === 'number' ? `<label class="payment-toggle ${booking.is_payment_required ? 'unpaid' : ''}">
                <input type="checkbox" class="payment-toggle-checkbox" ${!booking.is_payment_required ? 'checked' : ''} data-booking-id="${booking.id}" />
                <span class="payment-label">
                  $${(booking.price_cents / 100).toFixed(0)} paid
                </span>
              </label>` : ''}
              <div class="mt-1">
                <select class="booking-status-select text-xs border border-gray-300 rounded px-1 py-0.5 w-full" 
                        data-booking-id="${booking.id}" 
                        data-google-event-id="${booking.google_event_id || ''}"
                        data-original-status="${booking.status || 'confirmed'}">
                  <option value="confirmed" ${(booking.status || 'confirmed') === 'confirmed' ? 'selected' : ''}>Confirmed</option>
                  <option value="completed" ${booking.status === 'completed' ? 'selected' : ''}>Completed</option>
                  <option value="cancelled" ${booking.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                  <option value="no_show" ${booking.status === 'no_show' ? 'selected' : ''}>No Show</option>
                </select>
              </div>
            `;
          }
          
          bookingDiv.innerHTML = `
            <div class="booking-card-content">
              <div class="booking-card-text">
                <div class="booking-summary">
                  ${summaryHTML}
                </div>
                ${detailsHTML ? `<div class="booking-details">${detailsHTML}</div>` : ''}
              </div>
              <button class="booking-cancel-btn" data-booking-id="${booking.id}" data-google-event-id="${booking.google_event_id || ''}" title="Cancel booking" aria-label="Cancel booking">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="15" y1="9" x2="9" y2="15"></line>
                  <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
              </button>
            </div>
          `;
        } else {
          // This is a regular calendar appointment - show title and times
          bookingDiv.className = 'booking-card text-xs border-l-2 border-gray-400 p-1 rounded absolute left-0 right-0 z-10';
          bookingDiv.style.backgroundColor = '#f3f4f6';
          bookingDiv.style.color = '#374151';
          const padAdjust2 = isMobile ? 4 : 8;
          bookingDiv.style.height = `${Math.max(heightPx - padAdjust2, 4)}px`;
          bookingDiv.style.top = `${minuteOffset}px`;
          
          const eventTitle = booking.event_title || 'Appointment';
          
          bookingDiv.innerHTML = `
            <div class="booking-card-content">
              <div class="booking-card-text">
                <div class="font-semibold" style="color:#374151;">${eventTitle}</div>
                <div class="booking-time" style="color:#374151;">${time} - ${endTime}</div>
              </div>
              <button class="booking-cancel-btn" data-booking-id="${booking.id}" data-google-event-id="${booking.google_event_id || ''}" data-event-title="${eventTitle}" title="Cancel event" aria-label="Cancel event">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="15" y1="9" x2="9" y2="15"></line>
                  <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
              </button>
            </div>
          `;
        }
        
        cell.appendChild(bookingDiv);
      }
    });

    // Add event listeners to all status dropdowns
    document.querySelectorAll('.booking-status-select').forEach(select => {
      select.addEventListener('change', async function(e) {
        const bookingId = this.getAttribute('data-booking-id');
        const originalStatus = this.getAttribute('data-original-status');
        const newStatus = this.value;
        
        // Route to appropriate handler
        if (newStatus === 'cancelled') {
          // handleBookingCancellation will show confirmation via cancelWithConfirmation
          const confirmMessage = 'Are you sure you want to cancel this booking? This action cannot be undone.';
          await handleBookingCancellation(this, bookingId, originalStatus, null, confirmMessage);
        } else {
          // For other status changes, update immediately
          await updateBookingStatus(this, bookingId, newStatus, originalStatus);
        }
      });
    });
    
    // Add event listeners to all cancel buttons
    document.querySelectorAll('.booking-cancel-btn').forEach(btn => {
      btn.addEventListener('click', async function(e) {
        e.stopPropagation(); // Prevent card expansion on mobile
        
        const bookingId = this.getAttribute('data-booking-id');
        const googleEventId = this.getAttribute('data-google-event-id');
        const eventTitle = this.getAttribute('data-event-title');
        
        // Check if this is a regular event (has event-title) or a booking
        const isRegularEvent = !!eventTitle;
        
        // Prepare confirmation message based on event type
        const confirmMessage = isRegularEvent 
          ? `Are you sure you want to cancel "${eventTitle}"?`
          : 'Are you sure you want to cancel this booking? This action cannot be undone.';
        
        // handleBookingCancellation will show confirmation via cancelWithConfirmation
        await handleBookingCancellation(this, bookingId, null, googleEventId, confirmMessage);
      });
    });
    
    // Add event listeners to payment toggle checkboxes
    document.querySelectorAll('.payment-toggle-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', async function(e) {
        const bookingId = this.getAttribute('data-booking-id');
        const isPaid = this.checked;
        const isRequired = !isPaid; // Checkbox true = paid => is_payment_required = false
        
        console.log('[payment-toggle] Updating booking', bookingId, 'isPaid:', isPaid, 'is_payment_required:', isRequired);
        
        // Find the toggle container and store original state
        const toggleLabel = this.closest('.payment-toggle');
        const originalChecked = this.checked;
        const originalClass = toggleLabel.className;
        
        // Update UI optimistically
        if (isPaid) {
          toggleLabel.classList.remove('unpaid');
        } else {
          toggleLabel.classList.add('unpaid');
        }
        
        // Also update the $ marker in the title
        const bookingCard = this.closest('.booking-card');
        const titleElements = bookingCard.querySelectorAll('.booking-summary > div, .booking-details > div');
        titleElements.forEach(el => {
          const markerSpan = el.querySelector('.payment-marker');
          if (markerSpan) {
            markerSpan.style.display = isRequired ? 'inline' : 'none';
          }
        });
        
        try {
          // Update in Supabase
          const { error } = await window.supabaseClient
            .from('booking')
            .update({ is_payment_required: isRequired })
            .eq('id', bookingId);
          
          if (error) {
            console.error('[payment-toggle] Failed to update payment status:', error);
            // Revert UI on error
            this.checked = !originalChecked;
            toggleLabel.className = originalClass;
            
            // Revert $ marker
            titleElements.forEach(el => {
              const markerSpan = el.querySelector('.payment-marker');
              if (markerSpan) {
                markerSpan.style.display = !isRequired ? 'inline' : 'none';
              }
            });
            
            alert('Failed to update payment status. Please try again.');
          } else {
            console.log('[payment-toggle] Successfully updated payment status');
            
            // Update the booking object in memory so it stays in sync
            const bookingIndex = bookings.findIndex(b => b.id === bookingId);
            if (bookingIndex !== -1) {
              bookings[bookingIndex].is_payment_required = isRequired;
            }
          }
        } catch (err) {
          console.error('[payment-toggle] Exception updating payment status:', err);
          // Revert UI on exception
          this.checked = !originalChecked;
          toggleLabel.className = originalClass;
          alert('An error occurred. Please try again.');
        }
      });
    });
    
    // Wrap mobile setup in a function so it can be called on resize
    function setupMobileInteractions() {
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      
      if (!isMobile) {
        return;
      }
      
      // Create backdrop element
      let backdrop = document.getElementById('booking-backdrop');
      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.id = 'booking-backdrop';
        backdrop.className = 'booking-backdrop';
        document.body.appendChild(backdrop);
      }
      
      const cards = document.querySelectorAll('#section-calendar .booking-card');
      
      if (cards.length === 0) {
        // No cards yet - calendar may still be loading, this is normal
        return;
      }
      
      // Function to close all active bookings
      const closeAllBookings = () => {
        cards.forEach(c => {
          c.classList.remove('booking-active');
          // Temporarily disable pointer events to clear hover state
          c.style.pointerEvents = 'none';
          setTimeout(() => { c.style.pointerEvents = ''; }, 10);
        });
        backdrop.classList.remove('active');
        // Remove any injected close buttons to restore compact layout
        document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
      };
      
      // Remove existing backdrop listeners by replacing it
      const newBackdrop = backdrop.cloneNode(true);
      backdrop.parentNode.replaceChild(newBackdrop, backdrop);
      backdrop = newBackdrop;
      
      // Click backdrop to close
      backdrop.addEventListener('click', closeAllBookings);
      
      // Click calendar grid to close popup - use event delegation
      const calendar = document.getElementById('calendar');
      if (calendar) {
        // Remove old flag to allow re-adding listener
        if (calendar.dataset.mobileListenerAdded) {
          console.log('[mobile] Calendar listener already exists, skipping');
        } else {
          calendar.dataset.mobileListenerAdded = 'true';
          calendar.addEventListener('click', (e) => {
            // Only close if clicking the calendar itself or a grid cell, not a booking card
            if (!e.target.closest('.booking-card')) {
              const backdrop = document.getElementById('booking-backdrop');
              if (backdrop && backdrop.classList.contains('active')) {
                const cards = document.querySelectorAll('#section-calendar .booking-card');
                cards.forEach(c => {
                  c.classList.remove('booking-active');
                  // Temporarily disable pointer events to clear hover state
                  c.style.pointerEvents = 'none';
                  setTimeout(() => { c.style.pointerEvents = ''; }, 10);
                });
                backdrop.classList.remove('active');
                document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
              }
            }
          });
        }
      }
      
      // Clone each card to remove old event listeners, then add new ones
      cards.forEach((card, index) => {
        // Check if this card already has the listener
        if (card.dataset.mobileListenerAdded) {
          console.log('[mobile] Card', index, 'already has listener, skipping');
          return;
        }
        
        card.dataset.mobileListenerAdded = 'true';
        card.addEventListener('click', (e) => {
          console.log('[mobile] Card clicked');
          // Ignore clicks on the status dropdowns, close button, cancel button, or payment toggle
          if (e.target.closest('.booking-status-select')) return;
          if (e.target.closest('.booking-close-btn')) return;
          if (e.target.closest('.booking-cancel-btn')) return;
          if (e.target.closest('.payment-toggle')) return;

          e.stopPropagation();

          // Close others
          const allCards = document.querySelectorAll('#section-calendar .booking-card');
          allCards.forEach(c => {
            if (c !== card) c.classList.remove('booking-active');
          });

          // Toggle this one
          const isOpening = !card.classList.contains('booking-active');
          card.classList.toggle('booking-active');
          console.log('[mobile] Card toggled, isOpening:', isOpening);
          
          // Show/hide backdrop
          if (isOpening) {
            backdrop.classList.add('active');
            
            // Add close button if not already present
            if (!card.querySelector('.booking-close-btn')) {
              const closeBtn = document.createElement('button');
              closeBtn.className = 'booking-close-btn';
              closeBtn.innerHTML = '×';
              closeBtn.setAttribute('aria-label', 'Close');
              closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeAllBookings();
              });
              card.appendChild(closeBtn);
            }
          } else {
            backdrop.classList.remove('active');
            // Remove close button on closing this card
            const btn = card.querySelector('.booking-close-btn');
            if (btn) btn.remove();
          }
        });
      });
    }
    
    // Mobile: tap a blue block to toggle details
    setupMobileInteractions();
    
    // Handle window resize to clean up states when switching between desktop/mobile
    let resizeTimeout;
    let wasMobile = window.matchMedia('(max-width: 768px)').matches;
    
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const cards = document.querySelectorAll('#section-calendar .booking-card');
        const backdrop = document.getElementById('booking-backdrop');
        
        if (!isMobile) {
          // Switching to desktop: clean up mobile popup states
          cards.forEach(c => {
            c.classList.remove('booking-active');
            // Remove mobile listener flag so it can be re-added when switching back to mobile
            delete c.dataset.mobileListenerAdded;
          });
          if (backdrop) backdrop.classList.remove('active');
          document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
          
          // Clear calendar listener flag
          const calendar = document.getElementById('calendar');
          if (calendar) delete calendar.dataset.mobileListenerAdded;
          
          // If we just switched from mobile to desktop, refresh the calendar to recalculate heights
          if (wasMobile && !isMobile) {
            console.log('[calendar] Switched from mobile to desktop - refreshing calendar');
            renderWeek(weekStart);
          }
        } else if (wasMobile !== isMobile) {
          // Switching to mobile: re-setup mobile interactions and clean up
          console.log('[calendar] Switched from desktop to mobile - setting up mobile interactions');
          document.querySelectorAll('#section-calendar .booking-close-btn').forEach(btn => btn.remove());
          if (backdrop) backdrop.classList.remove('active');
          
          // Force remove hover states by temporarily disabling pointer events
          cards.forEach(c => {
            c.style.pointerEvents = 'none';
          });
          setTimeout(() => {
            cards.forEach(c => {
              c.style.pointerEvents = '';
            });
          }, 50);
          
          // Re-setup mobile interactions for existing cards
          setupMobileInteractions();
        }
        
        // Update the previous state
        wasMobile = isMobile;
      }, 100);
    });
    
    // Helper function to get current admin email
    async function getAdminEmail() {
      if (!window.supabaseClient) {
        console.error('[calendar] getAdminEmail: supabaseClient not available');
        return null;
      }
      
      try {
        const { data: { session } } = await window.supabaseClient.auth.getSession();
        return session?.user?.email || null;
      } catch (error) {
        console.error('[calendar] Error getting admin email:', error);
        return null;
      }
    }
    
    // Helper function to handle booking cancellation (used by both cancel button and status change)
    async function handleBookingCancellation(element, bookingId, originalStatus = null, googleEventId = null, confirmMessage = null) {
      // Get google event ID from element if not provided
      if (!googleEventId && element.hasAttribute('data-google-event-id')) {
        googleEventId = element.getAttribute('data-google-event-id');
      }
      
      // Get admin email
      const adminEmail = await getAdminEmail();
      
      // Use the unified cancellation function
      if (window.GoogleCalendar && window.GoogleCalendar.cancelWithConfirmation) {
        await window.GoogleCalendar.cancelWithConfirmation({
          bookingId: bookingId,
          googleEventId: googleEventId,
          cancelledBy: adminEmail,
          triggerElement: element,
          confirmMessage: confirmMessage, // Use custom message if provided
          showSuccessMessage: false, // Admin calendar refresh provides visual feedback
          onSuccess: async () => {
            // Refresh the calendar after successful cancellation
            console.log('[calendar] Refreshing calendar view...');
            setTimeout(() => renderWeek(weekStart), 500);
          },
          onCancel: () => {
            // User aborted - revert dropdown to original status
            if (element.tagName === 'SELECT' && originalStatus) {
              element.value = originalStatus;
            }
          },
          onError: (error) => {
            // If this is a status dropdown and we have an original status, revert to it
            if (element.tagName === 'SELECT' && originalStatus) {
              element.value = originalStatus;
            }
          }
        });
      } else {
        console.error('[calendar] GoogleCalendar.cancelWithConfirmation not available');
        alert('Cancellation feature not available. Please refresh the page.');
      }
    }
    
    // Helper function to update booking status
    async function updateBookingStatus(selectElement, bookingId, newStatus, originalStatus) {
      const originalBg = selectElement.style.backgroundColor;
      selectElement.style.backgroundColor = '#fef3c7'; // yellow-100
      selectElement.disabled = true;
      
      try {
        // If cancelling, use Google Calendar integration with admin email tracking
        if (newStatus === 'cancelled') {
          const googleEventId = selectElement.getAttribute('data-google-event-id');
          await handleBookingCancellation(selectElement, bookingId, originalStatus, googleEventId);
          return; // handleBookingCancellation manages the rest
        }
        
        // For non-cancellation status changes, update database directly
        const { error } = await window.supabaseClient
          .from('booking')
          .update({ status: newStatus })
          .eq('id', bookingId);
        
        if (error) {
          console.error('[calendar] Error updating status:', error);
          selectElement.value = originalStatus;
          alert('Failed to update booking status: ' + error.message);
          selectElement.style.backgroundColor = '#fee2e2'; // red-100
        } else {
          console.log('[calendar] ✅ Status updated successfully');
          selectElement.setAttribute('data-original-status', newStatus);
          selectElement.style.backgroundColor = '#d1fae5'; // green-100
          
          setTimeout(() => {
            selectElement.style.backgroundColor = originalBg;
          }, 1000);
        }
      } catch (err) {
        console.error('[calendar] Exception updating status:', err);
        selectElement.value = originalStatus;
        alert('Failed to update booking status: ' + err.message);
        selectElement.style.backgroundColor = '#fee2e2'; // red-100
      } finally {
        selectElement.disabled = false;
      }
    }
  }

  // Initialize calendar when this partial loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => renderWeek(new Date()));
  } else {
    renderWeek(new Date());
  }
})();
</script>
